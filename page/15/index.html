<!doctype html>
<html class="theme-next ">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="google-site-verification" content="h7BaHlqi6VjlciSt0RF-KHgIXZcGfx3L3gyQ9qfx_ek" />










  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.4.5.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="wuxu, Golang, C, CPP, CS, PHP, " />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.2" />






<meta name="description" content="Wu Xu的个人博客">
<meta property="og:type" content="website">
<meta property="og:title" content="Wu Xu">
<meta property="og:url" content="http://blog.wuxu92.com/page/15/index.html">
<meta property="og:site_name" content="Wu Xu">
<meta property="og:description" content="Wu Xu的个人博客">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Wu Xu">
<meta name="twitter:description" content="Wu Xu的个人博客">



<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: '',
    sidebar: 'hide',
    motion: false
  };
</script>

  <title> Wu Xu </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-72131273-1', 'auto');
  ga('send', 'pageview');
</script>





  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>
    <div class="bottomband"></div> <!-- add by wuxu -->
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Wu Xu</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">关注C、Go、C++、JavaScript和UX</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th fa-fw"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-user fa-fw"></i> <br />
            
            关于
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content">
          
  <section id="posts" class="posts-expand">

    

    
    
      
      

      
    

    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/notes-of-go-by-example-part-6/" itemprop="url">
                  Go by Example(六)：杂烩2
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-08-30T12:34:50+08:00" content="2015-08-30">
              2015-08-30
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/programming/" itemprop="url" rel="index">
                    <span itemprop="name">programming</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <h2 id="随机数-Rand"><a href="#随机数-Rand" class="headerlink" title="随机数/Rand"></a>随机数/Rand</h2><p>在之前的练习中，已经使用过随机数相关的函数了，比如随机休眠N毫秒：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">time.Sleep(time.Milliseond * time.Duration(rand.Intn(500) ))</span><br></pre></td></tr></table></figure>
<p>math/rand包提供了很多方法，上面的<code>Intn(n int)</code>方法就是放回n以内整数这是最常用的函数之一。另外常用的方法包括：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rand.Float64()  // 返回0-1之间的一个浮点数</span><br><span class="line">rand.Int31()</span><br><span class="line">rand.Uint32()</span><br></pre></td></tr></table></figure>
<p>和其他平台的随机数生成器一样，rand包提供的随机数序列也是伪随机数，如果不传入一个不同的种子/seed，得到的随机数序列将是确定的。我们常把时间作为随机数种子传入方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rs := rand.NewSource(time.Now().UnixNano())</span><br><span class="line">r := rand.New(rs)</span><br><span class="line">// r此时是一个新的随机数生成器</span><br><span class="line">// 正式使用应该这样</span><br><span class="line">r.Intn(100)</span><br></pre></td></tr></table></figure>
<h2 id="strconv-数字与字符串转换"><a href="#strconv-数字与字符串转换" class="headerlink" title="strconv/数字与字符串转换"></a>strconv/数字与字符串转换</h2><p>strconv包提供了字符串与数字类型的转换，这是一些很常用的功能，比如从”123”到123的转换，”1.23”转换到1.23;特别是在与客户端通信，使用json，或者处理从数据库查询的数据的时候，经常需要这类转换。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// parseFloat原型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseFloat</span><span class="params">(s <span class="keyword">string</span>, bitSize <span class="keyword">int</span>)</span> <span class="params">(f <span class="keyword">float64</span>, err error)</span></span></span><br><span class="line">f,_ := strconv.ParseFloat("1.23", 64)   // 转换到64位Float，不处理转换的错误</span><br><span class="line"></span><br><span class="line"><span class="comment">// parseInt的原型， base从2-36</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseInt</span><span class="params">(s <span class="keyword">string</span>, base <span class="keyword">int</span>, bitSize <span class="keyword">int</span>)</span> <span class="params">(i <span class="keyword">int64</span>, err error)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 更常用的</span></span><br><span class="line">k,_ := strconv.Atoi("123")  // k=123</span><br><span class="line">_,e := strconv.Atoi(<span class="string">"wrongFormat"</span>)  <span class="comment">// will return error</span></span><br></pre></td></tr></table></figure>
<p>其中最常用的是<code>Atoi(s tring)</code>和<code>Itoa(i int)</code>;strconv包提供的方法大部分会有两个返回值，第一个是转换的结果，第二个是是否转换成功的error。</p>
<h2 id="URL相关"><a href="#URL相关" class="headerlink" title="URL相关"></a>URL相关</h2><p>net/url包提供了对URL处理的方法，可以把一个字符转解析成一个url变量，通过提供的属性获取URL的各个部分。<br>我们自导一个完整的URL的模式是这样的： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scheme://[username:password@]host/path?querystring#fragement_id</span><br></pre></td></tr></table></figure>
<p>其中的host包括domain和port。</p>
<p>url包提供了把一个字符串解析成url，并提供访问上面模式中各个元素的方法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &quot;net/url&quot;</span><br><span class="line"></span><br><span class="line">urlStr := &quot;https://gobyexample.com/url-parsing?from=goole#url-parsing&quot;</span><br><span class="line">u, err := url.Parse(urlStr)</span><br><span class="line">if err != nil &#123;  fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(u.Scheme,u.Host, u.Path, u.Fragment, u.RawQuery)</span><br><span class="line">host, port, _ := net.SplitHostPort(u.Host)</span><br><span class="line"></span><br><span class="line">user := u.User</span><br><span class="line">username := &quot;null&quot;</span><br><span class="line">if user != nil &#123;</span><br><span class="line">  username = user.Username()  // user.Password()</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(&quot;username&quot;, username)</span><br><span class="line">// 解析queryString</span><br><span class="line">query, _ := url.ParseQuery(u.RawQuery)</span><br><span class="line">fmt.Println(query, query[&quot;from&quot;][0])</span><br></pre></td></tr></table></figure>
<blockquote>
<p>The parsed query param maps are from strings to slices of strings, so index into [0] if you only want the first value.</p>
</blockquote>
<p>注意querystring解析出来的map是一个建对应一个slice的。不是一一对应的字符串，这是因为请求时可能有相同的key，一般只取第一个。</p>
<h2 id="Hash-SHA1"><a href="#Hash-SHA1" class="headerlink" title="Hash/SHA1"></a>Hash/SHA1</h2><p>Go的crypto包及其子包中包括多种hash函数，我们最常用的MD5和SHA1都包含在里面。各种hash算法实现在各个子包中，比如md5在 <code>crypto/md5</code>, sha1在 <code>crypto/sha1</code>。<br>子包列表和简介：</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Synopsis</th>
</tr>
</thead>
<tbody>
<tr>
<td>aes</td>
<td>Package aes implements AES encryption (formerly Rijndael), as defined in U.S. Federal Information Processing Standards Publication 197.</td>
</tr>
<tr>
<td>cipher</td>
<td>Package cipher implements standard block cipher modes that can be wrapped around low-level block cipher implementations.</td>
</tr>
<tr>
<td>des</td>
<td>Package des implements the Data Encryption Standard (DES) and the Triple Data Encryption Algorithm (TDEA) as defined in U.S. Federal Information Processing Standards Publication 46-3.</td>
</tr>
<tr>
<td>dsa</td>
<td>Package dsa implements the Digital Signature Algorithm, as defined in FIPS 186-3.</td>
</tr>
<tr>
<td>ecdsa</td>
<td>Package ecdsa implements the Elliptic Curve Digital Signature Algorithm, as defined in FIPS 186-3.</td>
</tr>
<tr>
<td>elliptic</td>
<td>Package elliptic implements several standard elliptic curves over prime fields.</td>
</tr>
<tr>
<td>hmac</td>
<td>Package hmac implements the Keyed-Hash Message Authentication Code (HMAC) as defined in U.S. Federal Information Processing Standards Publication 198.</td>
</tr>
<tr>
<td>md5</td>
<td>Package md5 implements the MD5 hash algorithm as defined in RFC 1321.</td>
</tr>
<tr>
<td>rand</td>
<td>Package rand implements a cryptographically secure pseudorandom number generator.</td>
</tr>
<tr>
<td>rc4</td>
<td>Package rc4 implements RC4 encryption, as defined in Bruce Schneier’s Applied Cryptography.</td>
</tr>
<tr>
<td>rsa</td>
<td>Package rsa implements RSA encryption as specified in PKCS#1.</td>
</tr>
<tr>
<td>sha1</td>
<td>Package sha1 implements the SHA1 hash algorithm as defined in RFC 3174.</td>
</tr>
<tr>
<td>sha256</td>
<td>Package sha256 implements the SHA224 and SHA256 hash algorithms as defined in FIPS 180-4.</td>
</tr>
<tr>
<td>sha512</td>
<td>Package sha512 implements the SHA-384, SHA-512, SHA-512/224, and SHA-512/256 hash algorithms as defined in FIPS 180-4.</td>
</tr>
<tr>
<td>subtle</td>
<td>Package subtle implements functions that are often useful in cryptographic code but require careful thought to use correctly.</td>
</tr>
<tr>
<td>tls</td>
<td>Package tls partially implements TLS 1.2, as specified in RFC 5246.</td>
</tr>
<tr>
<td>x509</td>
<td>Package x509 parses X.509-encoded keys and certificates.</td>
</tr>
<tr>
<td>pkix</td>
<td>Package pkix contains shared, low level structures used for ASN.1 parsing and serialization of X.509 certificates, CRL and OCSP.</td>
</tr>
</tbody>
</table>
<p>hash用法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s := &quot;hash this string&quot;</span><br><span class="line">h := sha1.New() // 返回一个hash.Hash变量</span><br><span class="line">// Hash接口： https://golang.org/pkg/hash/#Hash 帮助理解</span><br><span class="line">h.Write([]byte(s))</span><br><span class="line">bs := h.Sum(nil) //Sum(b []byte) appends the current hash to b and returns the resulting slice.</span><br><span class="line">fmt.Println(s)</span><br><span class="line">fmt.Printf(&quot;%x\n&quot;, bs)  //Use the %x format verb to convert a hash results to a hex string.</span><br></pre></td></tr></table></figure>
<p>比php直接调用方法要麻烦一些，理解了倒也还好,比java和C#要方便一些。</p>
<h2 id="Encoding-编码相关"><a href="#Encoding-编码相关" class="headerlink" title="Encoding/编码相关"></a>Encoding/编码相关</h2><p>与编码相关的是encoding包和其子包。比如常用的base64的支持在<code>encoding/base64</code>。其用法为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sEncoded := base64.StdEncoding.EncodeToString([]byte(&quot;abcdef123&apos;=-=!=&quot;))</span><br><span class="line">fmt.Println(sEncoded)</span><br><span class="line">sDecoded := base64.StdEncoding.DecodeString(sEncoded)</span><br><span class="line">fmt.Println(string(sDecoded))</span><br><span class="line">urlEncoded := base64.URLEncoding.EncodeToString([]byte(&quot;你好&quot;))</span><br></pre></td></tr></table></figure>
<p>从上面可以看到encode和decode 是一对互逆的操作。StdEncoding 和 URLEncoding 的编码结果有一点点区别。</p>
<h2 id="待续"><a href="#待续" class="headerlink" title="待续"></a>待续</h2><p><em>后面将是文件操作，系统相关的内容，应该是最后一节了</em></p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/nginx-rewrite-and-try-files/" itemprop="url">
                  nginx重定向的几点[人生的]经验
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-08-27T12:34:50+08:00" content="2015-08-27">
              2015-08-27
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/server/" itemprop="url" rel="index">
                    <span itemprop="name">server</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>现在越来越多的server使用nginx做前端，在使用php的项目中越来越多的使用单一入口文件，而且很多时候希望隐藏这个入口文件，生成一个漂亮而简洁的url。以前在apache下是使用一个独立的rewrite模块，或者使用.htaccess文件实现重定向，nginx中需要小小的配置一下。</p>
<p>比如对于一个请求： <a href="http://localhost/index.php?r=c/a&amp;p=v" target="_blank" rel="noopener">http://localhost/index.php?r=c/a&amp;p=v</a> 这样，我们希望请求到 <a href="http://localhost/c/a?p=v。" target="_blank" rel="noopener">http://localhost/c/a?p=v。</a></p>
<p>比较老的做法是配置一个rewrite，以前的项目一般都是这么做的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">	if ($request_uri !~ &quot;/(index\.php)&quot;) &#123;</span><br><span class="line">        rewrite ^/(.*)$ /index.php/$1 last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这样做有可能会导致循环重定向而返回500错误页面。并且有一个问题，就是静态文件也会被转发到index.php。<br>静态文件转发到php-fpm不仅导致做了无用的工作，而且对于允许用户上传图片/文件的应用可能导致安全问题。这是非常不推荐的用法。</p>
<p>为了解决上面的问题，我试过一个稍微麻烦但是能正常工作的方案：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if ($request_uri !~ &quot;/static(.*)&quot; ) &#123;</span><br><span class="line">  set $test  A;</span><br><span class="line">&#125; </span><br><span class="line">if ( !-e $request_filename) &#123;</span><br><span class="line">  set $test &quot;$&#123;test&#125;B&quot;;</span><br><span class="line">&#125; </span><br><span class="line">if ($test = AB) &#123;</span><br><span class="line">  rewrite ^/(.*) /index.php/$1 last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里假设静态文件都存放在/static目录下。这样可以让静态资源文件不被转发。但是这个方案啊，总觉得不那么优雅。</p>
<p>今天在解决一个问题的时候正好又查了一下，发现现在更多的使用的try_files配置来做重写。try_files的语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try_files file ... uri</span><br><span class="line">try_files file ... = code</span><br></pre></td></tr></table></figure>
<p>其作用域是server 和location，并且不能放在if条件里面。最常用的用法是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try_files $uri $uri/ index.php</span><br></pre></td></tr></table></figure>
<p>下面简单解释一下，try_files顾名思义就是尝试读取文件，正是对于请求的脚本不存在的情况，给nginx一个尝试读取脚本的策略。第一个是<code>$uri</code>就是读取uri指定的文件，如果不存在就把请求的看作目录，查找目录下有没有默认index文件（一般配置为index.html, index.htm, index.php）;如果有则读取这个文件。对于try_files的最后一个参数，会作一个 内部重定向/fallback，这个内部重定向可以看作一个内部子请求，会重新被nginx配置match一遍。注意，<strong>只有最后一个参数会发起子请求</strong></p>
<p>在我们的配置里面最后一个参数是index.php这样，会发起一轮新的match会被nginx配置里面的 <code>location ~ .*\.(php|php5).*$ {}</code> catch然后进行转发到php-fpm解析。<br>当请求是静态文件时，因为能直接match的$uri，所以直接就返回静态文件的内容了，对于页面的请求就会转发到index.php.<br>这样就解决了index转发和静态文件不转发的问题，键值优雅得多了。但是有一个问题,那就是参数。</p>
<p>对一般的web框架来说，其请求的url一都是这样样式的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://host.com/index.php?r=controller/action&amp;param1=value1&amp;...</span><br><span class="line">// 要使用下面的url访问</span><br><span class="line">http://host.com/controller/action?param1=value1&amp;...</span><br></pre></td></tr></table></figure>
<p>需要注意的是，nginx在匹配try_files的最后一项时不会自动把args(也就是querystring)转发出去，需要手动加上，所以对于上面的需求，可以使用下面的配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try_files $uri $uri/ /index.php?r=$uri&amp;$args</span><br></pre></td></tr></table></figure>
<p>这样，对于<code>http://host.com/user/login?username=wuxu&amp;passwd=123</code>，$uri匹配到<code>user/login</code>，$args匹配到<code>username=wuxu&amp;password=123</code>,经过try_files配置之后就是<code>http://host.com/index.php?r=user/login&amp;username=wuxu&amp;password=123</code>了。（当然这里只是用login做示例，实际中的login可不能用GET传递参数哦）。</p>
<p>对于我们自己实现的框架可能有不同的路由方法，相应的修改try_files的策略就可以了。</p>
<p>当然try_files的最后一个参数还可以更复杂，具体可以看nginx的参考文档。</p>
<p>完。</p>
<p>参考: </p>
<ul>
<li><a href="http://wiki.nginx.org/NginxHttpCoreModule#try_files" title="http://wiki.nginx.org/NginxHttpCoreModule#try_files" target="_blank" rel="noopener">http://wiki.nginx.org/NginxHttpCoreModule#try_files</a></li>
<li><a href="https://servers.ustclug.org/2014/09/nginx-try_files-fallacy/" title="https://servers.ustclug.org/2014/09/nginx-try_files-fallacy/" target="_blank" rel="noopener">https://servers.ustclug.org/2014/09/nginx-try_files-fallacy/</a></li>
</ul>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/notes-of-go-by-example-part-5/" itemprop="url">
                  Go by Example(五)：杂烩1
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-08-26T12:34:50+08:00" content="2015-08-26">
              2015-08-26
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/lang/" itemprop="url" rel="index">
                    <span itemprop="name">lang</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <h2 id="排序包-sort"><a href="#排序包-sort" class="headerlink" title="排序包/sort"></a>排序包/sort</h2><p>go内置的sort包提供了内置类型和用户自定义类型的排序功能。需要注意的sort包的方法对传入的参数排序后直接修改参数，而不是返回一个新的数组。可以这么理解：一般传入排序的是一个数组，数组一般作为引用传递，而对于引用传递的修改直接反映在原数组上。<br>sort包提供对数组排序的函数，函数名为待排序数组元素类型加s，参数为待排序数组，比如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">strs := []string&#123;&quot;bcd&quot;, &quot;abk&quot;, &quot;opq&quot;, &quot;hij&quot;&#125;</span><br><span class="line">sort.Strings(strs)</span><br><span class="line">// strs has been sorted</span><br><span class="line">sort.StringsAreSorted(strs) // true</span><br></pre></td></tr></table></figure>
<p>同样对于int数组的排序方法为<code>sort.Ints(ints)</code> sort包还提供了一个判断数组是否排序的系列方法，其方法名为参数类型加s加AreSorted(); 比如 <code>IntsAreSorted(ints), StringsAreSorted(strs)</code></p>
<h2 id="给自定义类型排序"><a href="#给自定义类型排序" class="headerlink" title="给自定义类型排序"></a>给自定义类型排序</h2><p>类似于java与其他面向对象语言可以为实现了sortable接口的对象数组进行排序，go也提供了为自定义类型数组进行排序的方法。<code>sort.Sort(myArray)</code>中myArray是一个自定义的类型，它是某种类型的数组类型。比如:</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> myType []<span class="keyword">string</span></span><br></pre></td></tr></table></figure>
<p>要实现排序，也需要为这种类型绑定一些方法，就像实现sortable接口的方法一样。实际上绑定这些方法也是实现go内置定义的 <a href="https://golang.org/pkg/sort/#Interface" title="https://golang.org/pkg/sort/#Interface" target="_blank" rel="noopener">sort.Interface</a>, 要实现Len（） int, Swap和Less() bool三个方法。<br>
          <div class="post-more-link text-center">
            <a class="btn" href="/notes-of-go-by-example-part-5/" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/compile-openresty-in-centos/" itemprop="url">
                  编译安装openresty
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-08-26T12:34:50+08:00" content="2015-08-26">
              2015-08-26
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/server/" itemprop="url" rel="index">
                    <span itemprop="name">server</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <p>openresty是章亦春（agentzh）维护的项目，早期由淘宝网赞助，后来作者加入cloudflare公司后，也就由该公司支持了。这是一个扩展nginx的项目，在nginx的基础上添加很多作者开发的模块。该项目目前有很多公司在使用。</p>
<p>openresty项目主页 <a href="http://openresty.org/cn/" title="http://openresty.org/cn/" target="_blank" rel="noopener">http://openresty.org/cn/</a>， <a href="http://github.com/agentzh/openresty.org" title="http://github.com/agentzh/openresty.org" target="_blank" rel="noopener">GITHUB</a>。</p>
<p>我们要安装一个openresty作为webserver同时把它配置成与nginx使用方式相同。</p>
          <div class="post-more-link text-center">
            <a class="btn" href="/compile-openresty-in-centos/" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/notes-of-go-by-example-part-4/" itemprop="url">
                  Go by Example(四)： atomic&mutex&stateful goroutine
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-08-25T12:34:50+08:00" content="2015-08-25">
              2015-08-25
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/programming/" itemprop="url" rel="index">
                    <span itemprop="name">programming</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <h2 id="原子性计数-atomic"><a href="#原子性计数-atomic" class="headerlink" title="原子性计数/atomic"></a>原子性计数/atomic</h2><p>在过线程场景下，进行全局的技术是很麻烦的，在java中我们需要使用加锁去实现一段互斥代码，go提供的sync包中有一些专门用来计数的封装。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var counter uint64 = 0;</span><br><span class="line">for ci:=0; ci&lt;50; ci++ &#123;</span><br><span class="line">  go func() &#123;</span><br><span class="line">    for &#123;</span><br><span class="line">      atomic.AddUint64(&amp;counter, 1)</span><br><span class="line">      runtime.Gosched()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;()</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(time.Second * 1)</span><br><span class="line">cResult := atomic.LoadUint64(&amp;counter)</span><br><span class="line">fmt.Println(&quot;counter result is &quot;, cResult)</span><br></pre></td></tr></table></figure>
<p>注意sync包的方法都需要传入指针作为实参。还有goroutine中的<code>runtime.Gosched()</code>是明确指定go调度器切换上下文（使得其他goroutine也能运行）；在无线有无限循环的goroutine中，应该在合适的地方添加这一调用。可以在 <a href="http://stackoverflow.com/questions/13107958/what-exactly-does-runtime-gosched-do" title="http://stackoverflow.com/questions/13107958/what-exactly-does-runtime-gosched-do" target="_blank" rel="noopener">stackoverflow</a> 了解更多关于Gosched()的知识。</p>
<h2 id="互斥器-mutex"><a href="#互斥器-mutex" class="headerlink" title="互斥器/mutex"></a>互斥器/mutex</h2><p>mutex在操作系统中是很重要的一部分，在资源调度/分配中，经常需要使用mutex防止资源同时被多个线程修改导致异常。在go中因为可以有多个goroutine执行，所以也存在同步互斥的问题。</p>
<p><a href="https://gobyexample.com/mutexes" title="https://gobyexample.com/mutexes" target="_blank" rel="noopener">https://gobyexample.com/mutexes</a></p>
<p><em>待更新</em></p>
<h2 id="goroutine的状态-stateful-goroutine"><a href="#goroutine的状态-stateful-goroutine" class="headerlink" title="goroutine的状态/stateful goroutine"></a>goroutine的状态/stateful goroutine</h2><p>我们可以通过除斥锁来在多个goroutine共享状态，另外也可以通过go语言goroutine和channel的内置特性来实现。这种基于channel的实现方式，和goroutine通过通信来共享内存来确保一块数据只被唯一的一个goroutine所有的思路是一样的。</p>
<blockquote>
<p>This channel-based approach aligns with Go’s ideas of sharing memory by communicating and having each piece of data owned by exactly 1 goroutine</p>
</blockquote>
<p>实际上并不是goroutine本身拥有某种状态，我们这里讲述的也是一种编程的模式/模型，通过goroutine和channel的结合实现一种互斥访问的机制。<br>它的思路是这样的，有两个所有goroutine共享的channel，就叫它们reads 和 writes，共享的内存区域/变量由一个goroutine所有，我们把这个共享的变量叫做state，它是一个map；这个goroutine负责从state里面读取或者写入数据，当reads或者writes channel有新的任务到来时（任务由其他goroutine添加）。<br>其他的goroutine需要读取一个状态的时候，就往reads channel中传入一个值，然后等待reads操作返回。要写入的话也同理。<br>这里要设计reads和writes的数据结构了。也就是这两个channel的类型，reads是要读取，需要传入一个索引，假设是int型的索引，读取的结果希望也存在一个channel中来实现同步；writes则需要传入索引，值和写入数据以及完成的channel。设计如下：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> read <span class="keyword">struct</span> &#123;</span><br><span class="line">  key <span class="keyword">int</span></span><br><span class="line">  req <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> write <span class="keyword">struct</span> &#123;</span><br><span class="line">  key <span class="keyword">int</span></span><br><span class="line">  value <span class="keyword">int</span></span><br><span class="line">  req <span class="keyword">chan</span> <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的key和chan的类型是有共享的map决定的，我们假设共享的map是<code>map[int]int</code>的如果是其他的map则要相应的修改。</p>
<p>这两个结构就是我们通信用的数据。下面新建两个所有goroutine共享的channel:</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">reads := <span class="built_in">make</span>(<span class="keyword">chan</span> *read) <span class="comment">// 注意是指针类型</span></span><br><span class="line">writes := <span class="built_in">make</span>(<span class="keyword">chan</span> *write)</span><br></pre></td></tr></table></figure>
<p>创建管理共享变量的goroutine：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// state manage gr</span><br><span class="line">go func() &#123;</span><br><span class="line">  state := make(map[int]int)  // 共享的变量</span><br><span class="line">  for &#123;</span><br><span class="line">    select &#123;</span><br><span class="line">      case r:= &lt;-reads:  // 如果reads有新的任务</span><br><span class="line">        r.req &lt;- state[r.key] // 把值写入channel</span><br><span class="line">      case w:= &lt;-writes: // 如果writes有新的任务</span><br><span class="line">        state[w.key] = w.value // 把值写入共享变量</span><br><span class="line">        w.req &lt;- true // 通知返回</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>
<p>然后就可以访问共享变量了，读取示例：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> ri := <span class="number">0</span>; ri&lt;<span class="number">20</span>; ri++ &#123;</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">      r := &amp;read &#123;  <span class="comment">// 注意取地址符</span></span><br><span class="line">        key: rand.Intn(<span class="number">10</span>),</span><br><span class="line">        req: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>),</span><br><span class="line">      &#125;</span><br><span class="line">      reads &lt;- r</span><br><span class="line">      res := &lt;-r.req</span><br><span class="line">      _ = res <span class="comment">// 暂时不用</span></span><br><span class="line">      atomic.AddInt64(&amp;ops, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写入示例：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> wi:=<span class="number">0</span>; wi&lt;<span class="number">10</span>; wi++ &#123;</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">      w := &amp;write&#123;</span><br><span class="line">        key: rand.Intn(<span class="number">10</span>),</span><br><span class="line">        value: rand.Intn(<span class="number">100</span>),</span><br><span class="line">        req: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>),</span><br><span class="line">      &#125;</span><br><span class="line">      writes &lt;- w</span><br><span class="line">      res := &lt;- w.req</span><br><span class="line">      _ = res <span class="comment">// 暂时不用</span></span><br><span class="line">      atomic.AddInt64(&amp;ops, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">opsFinal := atomic.LoadInt64(&amp;ops)</span><br><span class="line">fmt.Println(<span class="string">"total ops:"</span>, opsFinal)</span><br></pre></td></tr></table></figure>
<p>关于使用：</p>
<blockquote>
<p>It might be useful in certain cases though, for example where you have other channels involved or when managing multiple such mutexes would be error-prone. You should use whichever approach feels most natural, especially with respect to understanding the correctness of your program.</p>
</blockquote>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/notes-of-go-by-example-part-3/" itemprop="url">
                  Go by Example(三)： Timer & Ticker
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-08-24T12:34:50+08:00" content="2015-08-24">
              2015-08-24
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/programming/" itemprop="url" rel="index">
                    <span itemprop="name">programming</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <h2 id="定时器-Timer"><a href="#定时器-Timer" class="headerlink" title="定时器 Timer"></a>定时器 Timer</h2><p>在之前的部分中，已经使用过超时与睡眠(sleep)了。但是更一般的，我们可能想要某段代码在规定的时间执行，或者重复执行。Go内置的timer和ticker可以方便的实现这些功能。<br>timer包含在time包中，使用如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &quot;time&quot;</span><br><span class="line">...</span><br><span class="line">// 定义一个timer，超时设定2秒</span><br><span class="line">timer1 := time.NewTimer(time.Second *２）</span><br><span class="line">// 在此等待2s</span><br><span class="line">&lt;- timer1.C  //注意.C</span><br></pre></td></tr></table></figure>
<p>上面的代码使用timer在某个代码点阻塞等待2秒。但是，如果我们想要实现的知识阻塞等待一段时间，更应该使用time.Sleep()方法。timer的特性在于它是可以取消/stop的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">t2 := time.NewTimer(time.Second * 1)</span><br><span class="line">go func() &#123;</span><br><span class="line">	&lt;- t2.C</span><br><span class="line">	... // other code</span><br><span class="line">&#125;()</span><br><span class="line">stop2 := t2.Stop()</span><br></pre></td></tr></table></figure>
<p>实际上在上面的代码中，other code部分<strong>不会被执行</strong>，因为goroutine中的t2在主函数中被stop了， &lt;-t2.C 没有机会到达expire点。</p>
<h2 id="Tickers"><a href="#Tickers" class="headerlink" title="Tickers"></a>Tickers</h2><p>timer可以定时执行某段代码，而ticker就像打点器一样循环执行某代码。其作用有点像js中的<code>setTimeout()</code>和<code>setInterval()</code><br>同时可以把ticker看作一个channel，在初始化时定义一个循环时间，每过一段时间往channel里面塞一个数，然后我们循环去取，这样就实现了循环执行代码的功能，看起来比js的<code>setInterval</code>要麻烦你一点点。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">t1 := time.NewTicker(time.Millisecond * 500)</span><br><span class="line">go func() &#123;</span><br><span class="line">	for t := range t1.C &#123;</span><br><span class="line">		fmt.Println(&quot;tick tick @ &quot;, t)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;()</span><br><span class="line">time.Sleep(time.Second * 3)</span><br><span class="line">t1.Stop()</span><br><span class="line">fmt.Println(&quot;tick tick stop&quot;)</span><br></pre></td></tr></table></figure>
<p>上面会打印6次“tick tick @***”,range ticker.C会返回时间戳。<br>我们看一下ticker的实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type Ticker struct &#123;</span><br><span class="line">        C &lt;-chan Time // The channel on which the ticks are delivered.</span><br><span class="line">        // contains filtered or unexported fields</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>果然起始ticker就是包含一个chan成员的结构体，这样理解起来就更加方便了。</p>
<h2 id="worker-pool-worker池"><a href="#worker-pool-worker池" class="headerlink" title="worker pool/worker池"></a>worker pool/worker池</h2><p>worker这个概念在很多地方都有，印象比较深刻的是在异步javascript编程那篇文章里面讲了很多worker的东西。<br>这里worker pool主要是借助channel来实现使用多个goroutine处理多个work的<strong>编程模型</strong>。可以把一个goroutine看作一个worker。给多个worker传入相同的channel，worker从channel中取任务并处理，主线程往channel中添加任务，这样过个goroutine处理一个任务队列。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jobs := make(chan int, 100)</span><br><span class="line">result := make(chan int, 100)</span><br><span class="line">// use five workers</span><br><span class="line">for w:=0; w&lt;5; w++ &#123;</span><br><span class="line">  go func(w int, jobs &lt;-chan int, result chan&lt;- int) &#123;</span><br><span class="line">    for j:= range jobs &#123;</span><br><span class="line">      fmt.Println(&quot;worker&quot;, w, &quot;processing on&quot;, j)    </span><br><span class="line">      time.Sleep(time.Millisecond * time.Duration(rand.Intn(600))) // sleep a random time</span><br><span class="line">      result &lt;- j * 2</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;(w, jobs, result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// insert jobs</span><br><span class="line">for j:=0; j&lt;10; j++ &#123;</span><br><span class="line">  jobs &lt;- j</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">close(jobs)</span><br><span class="line"></span><br><span class="line">// can do some others here</span><br><span class="line"></span><br><span class="line">// sync here, may wait for works done</span><br><span class="line">for a :=0; a&lt;10; a++ &#123;</span><br><span class="line">  &lt;- result</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(&quot;all work done here&quot;)</span><br></pre></td></tr></table></figure>
<h2 id="限速-rate-limiting"><a href="#限速-rate-limiting" class="headerlink" title="限速/rate-limiting"></a>限速/rate-limiting</h2><p>关于rate-limiting,可以参考 <a href="https://en.wikipedia.org/wiki/Rate_limiting" title="https://en.wikipedia.org/wiki/Rate_limiting" target="_blank" rel="noopener">维基百科</a></p>
<blockquote>
<p>Rate limiting is an important mechanism for controlling resource utilization and maintaining quality of service</p>
</blockquote>
<p>go使用goroutine，channel， ticker合作实现该特性。</p>
<p>使用rate-limiting的模型，可以应对突然的大量请求进行缓存，有序处理。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rateControlChan := make(chan time.Time, 3) // 用于控制速率的channel</span><br><span class="line">for i:=0; i&lt;3; i++ &#123;</span><br><span class="line">  rateControlChan &lt;- time.Now()</span><br><span class="line">&#125;</span><br><span class="line">// send value per 200 millisecond</span><br><span class="line">go func() &#123;</span><br><span class="line">  for t := range time.Tick(time.Millisecond * 200) &#123;</span><br><span class="line">    rateControlChan &lt;- t</span><br><span class="line">  &#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">reqChannel := make(chan int, 5) // 缓存请求的channel</span><br><span class="line">for i:=0; i&lt; 5; i++ &#123;</span><br><span class="line">  reqChannel &lt;- i</span><br><span class="line">&#125;</span><br><span class="line">close(reqChannel)</span><br><span class="line">for r:= range reqChannel &#123;</span><br><span class="line">  ht := &lt;- rateControlChan // wait for rate-control condition</span><br><span class="line">  // handle request here</span><br><span class="line">  fmt.Println(&quot;req&quot;, r, &quot;handle at&quot;, ht)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个模型的关键是，使用两个channel协同，一个用于处理速率的控制，一个用于请求的缓冲。使用一个goroutine不断的定时填充速率控制goroutine，而请求channel则用一个for-range不停行从里面取请求</p>
<h2 id="待续"><a href="#待续" class="headerlink" title="待续"></a>待续</h2><p><em>下一部分主要是原子性，同步与互斥</em></p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/notes-of-go-by-example-part-2/" itemprop="url">
                  Go by Example(二)： goroutine & channel
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-08-23T12:34:50+08:00" content="2015-08-23">
              2015-08-23
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/programming/" itemprop="url" rel="index">
                    <span itemprop="name">programming</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <h2 id="Goroutines"><a href="#Goroutines" class="headerlink" title="Goroutines"></a>Goroutines</h2><p>goroutines就是可以方便的并行执行函数，本身并没有太多东西要注意的，主要的内容在于goroutine和channel结合的并发程序</p>
<h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><p>channel相当于联系并发的goroutine的管道，我们常使用Linux中的管道pipe做类比：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ls -l | grep .go</span><br></pre></td></tr></table></figure>
<p>上面的命令把当前目录下的文件列出，每个文件占一行，用管道把输出结果送到grep程序的标准输入流，grep把当前目录下的go源程序文件筛选出来。管道吧ls程序和grep程序连接起来，goroutine的作用也差不多，把一个goroutine的输出，可以在另外一个goroutine读出来。<br>当然channel要比Linux的管道功能更加强大一些，因为是可编程的，它可以传递任意规定的类型的变量，使用也很方便。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">msgChannel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;msgChannel &lt;- <span class="string">"hello"</span>&#125;()</span><br><span class="line">msg := &lt;-msgChannel <span class="comment">// receive a msg from channel</span></span><br></pre></td></tr></table></figure>
<p>上面的代码即声明了一个可传递string类型的channel。第3行代码则使用goroutine执行一个匿名函数，函数的作用是向msgChannel传入一个字符串。</p>
<blockquote>
<p>goroutine执行一个匿名还是得语法是很有用的，其格式为<code>go func() { ... }()</code>注意最后的括号表示执行匿名函数。</p>
</blockquote>
<p><code>channel &lt;-</code>通常叫做发送操作，即向channel发送一个值。<code>&lt;- channel</code>通常叫做接受操作，即从channel中取出一个值。<br>channel的发送和接受是一个同步的过程，只有sender和receiver都准备就绪的时候才能发送/接受，否则会阻塞等待，这在后面的Channel Buffering 中会讲到。</p>
<h3 id="Channel-Buffering"><a href="#Channel-Buffering" class="headerlink" title="Channel Buffering"></a>Channel Buffering</h3><p>默认的channel是不带缓冲的（unbuffered）如果像上面的方式定义channel的话，只能往里面添加一个元素，并且需要有从channel取数据的receiver，否则再往里面添加元素则会导致无限等待。<br>所以更常见的是使用带缓冲的channel，这样可以一次性往channel里面添加多个元素。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">msgChannel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">msgChanenl &lt;- <span class="string">"hello"</span></span><br><span class="line">msgChannel &lt;- <span class="string">"world"</span></span><br><span class="line"></span><br><span class="line">fmt.Println(&lt;-msgChannel)</span><br><span class="line">fmt.Println(&lt;-msgChannel)</span><br></pre></td></tr></table></figure>
<p>这样就channel就可以缓存两个变量了。在实际使用中，常会使用更大的缓存channel。</p>
<h3 id="使用channel同步goroutine"><a href="#使用channel同步goroutine" class="headerlink" title="使用channel同步goroutine"></a>使用channel同步goroutine</h3><p>我们知道channel的发送和接受操作只有在channel准备就绪时才会进行，否则会阻塞等待，也就是说在向channel发送数据时，需要channel有空余空间，从channel接受数据时，需要channel不能为空，否则也会阻塞等待。如下的代码展示了一个使用不带缓冲的channel实现同步的功能:</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">working</span><span class="params">(flagChan <span class="keyword">chan</span> <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">"working on it"</span>)</span><br><span class="line">  time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">  fmt.Println(<span class="string">"work done"</span>)            </span><br><span class="line"></span><br><span class="line">  flagChan &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanSync</span><span class="params">()</span></span> &#123;</span><br><span class="line">  flagChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">go</span> working(flagChan)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 下面的接受操作会阻塞等待goroutine执行结束</span></span><br><span class="line">  done := &lt;- flagChan </span><br><span class="line">  fmt.Println(<span class="string">"sync goroutine output"</span>, done)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="指定channel的方向（操作）"><a href="#指定channel的方向（操作）" class="headerlink" title="指定channel的方向（操作）"></a>指定channel的方向（操作）</h3><p>我们可以在方法的定义的参数列表处指定channel参数的操作方式为发送或者接受，因为一般发送是一个逻辑，接受是一个逻辑，通常不会把两个操作放在一起，指定某个函数的操作模式可以起到“代码即文档”的作用。比如上面的working函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">working</span> <span class="params">(flagChan <span class="keyword">chan</span>&lt;- <span class="keyword">bool</span>)</span></span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recv</span> <span class="params">(flagChan &lt;-<span class="keyword">chan</span> <span class="keyword">bool</span>)</span></span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>即表明了在函数中channel的数据流向（directions）<br>网页中的代码示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line">func pong(pings &lt;-chan string, pongs chan&lt;- string) &#123;</span><br><span class="line">    msg := &lt;-pings</span><br><span class="line">    pongs &lt;- msg</span><br><span class="line">&#125;</span><br><span class="line">func ping(pings chan&lt;- string, msg string) &#123;</span><br><span class="line">    pings &lt;- msg</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">    pings := make(chan string, 1)</span><br><span class="line">    pongs := make(chan string, 1)</span><br><span class="line">    ping(pings, &quot;passed message&quot;)</span><br><span class="line">    pong(pings, pongs)</span><br><span class="line">    fmt.Println(&lt;-pongs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多路goroutine-select"><a href="#多路goroutine-select" class="headerlink" title="多路goroutine: select"></a>多路goroutine: select</h2><p>select用于从多个channel中轮询状态，从已经准备就绪的channel中接受值并执行相应的代码。select的语法和switch有点相似。请看代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import (</span><br><span class="line">	&quot;math/rand&quot;</span><br><span class="line">	&quot;time&quot;</span><br><span class="line">	&quot;strconv&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func gr1(c chan string) &#123;</span><br><span class="line">  dur := rand.Intn(300)</span><br><span class="line">  time.Sleep(time.Millisecond * time.Duration(dur))</span><br><span class="line">  c &lt;- &quot;gr1 sleep done &quot; + strconv.Itoa(dur)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func gr2(c chan string) &#123;</span><br><span class="line">  dur := rand.Intn(400)</span><br><span class="line">  time.Sleep(time.Millisecond * time.Duration(dur))</span><br><span class="line">  c &lt;- &quot;gr2 sleep done &quot; + strconv.Itoa(dur)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func selects() &#123;</span><br><span class="line">  c1 := make(chan string)</span><br><span class="line">  c2 := make(chan string)</span><br><span class="line">  go gr1(c1)</span><br><span class="line">  go gr1(c1)</span><br><span class="line">  go gr2(c2)</span><br><span class="line">  go gr2(c2)</span><br><span class="line"></span><br><span class="line">  for i:=0; i&lt;4; i++ &#123;</span><br><span class="line">    select &#123;</span><br><span class="line">    case msg := &lt;-c1:</span><br><span class="line">      fmt.Println(msg)</span><br><span class="line">    case msg2 := &lt;-c2:</span><br><span class="line">      fmt.Println(msg2)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要注意，channel的send与receive操作的个数必须是匹配的，否则会无限阻塞等待。</p>
<h2 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h2><p>在访问资源的代码中，我们常需要绑定一个超时时间，如果超过一段时间没有加载到资源，或者某个调用没有返回则需要做出相应的处理。<br>一个例子就是在channel的接受操作，等待一定时间没有资源可以接受则执行预定代码。可以在select中添加一个超时：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select &#123;</span><br><span class="line">case res &lt;- c1 :</span><br><span class="line">	fmt.Println(res)</span><br><span class="line">case &lt;-time.After(time.Seconde * 2)</span><br><span class="line">	fmt.Println(&quot;timeout&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以理解，time.After()是一个特殊的channel。</p>
<h2 id="非阻塞的channel操作"><a href="#非阻塞的channel操作" class="headerlink" title="非阻塞的channel操作"></a>非阻塞的channel操作</h2><p>在上面的例子里面，channel进行send/receive操作时，是阻塞的，有什么办法让channel的操作变得不是阻塞的呢，比如从一个channel中取数据，如果没有数据则直接执执行一个默认的操作，也不要想刚刚讨论的超时那样设置要给time.After().</p>
<p>刚刚我们说了select的语法和switch很相似，那switch中有default可以用来指定当所有case不没有match到的情况，select是不是也有呢？答案是肯定的。</p>
<p>我们可以为select操作添加一个default分支。一般在所有case之后。这样在所有case的channel都没有就绪的时候执行default的分支代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select &#123;</span><br><span class="line">case msg := &lt;-c1:</span><br><span class="line">  fmt.Println(msg)</span><br><span class="line">case msg2 := &lt;-c2:</span><br><span class="line">  fmt.Println(msg2)</span><br><span class="line">default:</span><br><span class="line">  // non-blocking channel</span><br><span class="line">  fmt.Println(&quot;select default&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="关闭channel"><a href="#关闭channel" class="headerlink" title="关闭channel"></a>关闭channel</h2><p>关闭一个channel意味着不再有数据发送到channel中，这在给接收者一个通信完成的信号时是很有用的。<br>关闭channel的操作很简单，直接调用<code>close(chan)</code>方法即可（在所有数据被发送完后调用close）。<br>在channel的接受操作时，其实可以指定两个变量:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msg, more := &lt;- msgChannel</span><br></pre></td></tr></table></figure>
<p>如果channel被关闭了，则more被赋值为false，否则more的值为true。 可以用<code>_, more := &lt;- channel</code> 判断一个channel是否被关闭了。</p>
<h2 id="range-over-channels"><a href="#range-over-channels" class="headerlink" title="range over channels"></a>range over channels</h2><p>可以使用range遍历一个channel中的元素。使用方法也很简单</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func rangeChannel() &#123;</span><br><span class="line">  c := make(chan string, 2)</span><br><span class="line">  c &lt;- &quot;tomorrow is monday&quot;</span><br><span class="line">  c &lt;- &quot;fee out&quot;</span><br><span class="line">  close(c)</span><br><span class="line">  for str := range c &#123;</span><br><span class="line">    fmt.Println(str)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要注意，对于一个close了得channel，range能自动判断是否遍历结束，但是如果channel没有调用过close，在上面的代码中，会在接受第三个值的时候阻塞(异常退出)。</p>
<h2 id="待续"><a href="#待续" class="headerlink" title="待续"></a>待续</h2><p><em>第二部分结束</em> </p>
<p>last update: 2015-08-23 10:38:00</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/using-sed-tool-process-text/" itemprop="url">
                  使用sed处理文本
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-08-21T12:34:50+08:00" content="2015-08-21">
              2015-08-21
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>Linux的文本处理工具除了awk之外，还有一个利器，那就是sed。sed用于文本的替换，也是以行为单位，使用正则表达式进行匹配。</p>
<p>参考： <a href="http://coolshell.cn/articles/9104.html" title="http://coolshell.cn/articles/9104.html" target="_blank" rel="noopener">http://coolshell.cn/articles/9104.html</a></p>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>sed的命令模式是这样的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -i <span class="string">'sed-command'</span> file-to-process</span><br></pre></td></tr></table></figure>
<p>其中，-i参数是很常用的，如果不带-i参数处理的结果会在终端打印出来，带上-i参数后会将处理结果<strong>替换输入文件</strong>的内容。</p>
<p>中间引号内的是sed的命令内容，常用单引号，但是要注意在单引号里面，反斜杠()转义将不能起作用。命令常用模式为 <code>s/old-pattern/new-str/g</code><br>最后的是要处理的文本的文件名。</p>
<p>由于sed主要依赖正则匹配实现功能，所以先熟悉一下基础的正则规则：</p>
<ul>
<li>^ 表示一行的开头。如：<code>/^#/</code> 以#开头的匹配。</li>
<li>$ 表示一行的结尾。如：<code>/}$/</code> 以}结尾的匹配。</li>
<li><code>\&lt;</code> 表示词首。 如 \&lt;abc 表示以 abc 为首的詞。</li>
<li><code>\&gt;</code> 表示词尾。 如<code>abc\&gt;</code> 表示以 abc 結尾的詞。</li>
<li>. 表示任何单个字符。</li>
<li><code>*</code> 表示某个字符出现了0次或多次。</li>
<li><code>[ ]</code>字符集合。 如：<code>[abc]</code>表示匹配a或b或c，还有<code>[a-zA-Z]</code>表示匹配所有的26个字符。如果其中有<strong>^表示反</strong>，如<code>[^a]</code>表示非a的字符</li>
</ul>
<p>练习：下面的命令可以去掉html文件中的标签，只留下文本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -i <span class="string">"s/&lt;[^&gt;]*&gt;//g"</span> index.html</span><br></pre></td></tr></table></figure>
<p>其中，命令开头的s代表替换，<code>[^&gt;]*</code>表示一个以上的非&gt;字符，替换为空。</p>
<p>上面的命令如果是:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed -i &apos;s/&lt;.*&gt;//g&apos; index.html</span><br></pre></td></tr></table></figure>
<p>看起来也好像能工作，但是， &lt;.*&gt;会匹配最长的尖括号内容，即从文本的第一个&lt; 到最后一个&gt;，这样达不到我们的效果。</p>
<h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><h3 id="指定替换"><a href="#指定替换" class="headerlink" title="指定替换"></a>指定替换</h3><p><strong>替换指定行的内容</strong><br>有时候我们仅需要对某些行进行替换，可以在命令中指定行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 只对第3行进行替换</span></span><br><span class="line">sed -i <span class="string">'3s/me/you/g'</span> file-name</span><br><span class="line"></span><br><span class="line"><span class="comment">#只对第3-6行替换</span></span><br><span class="line">sed -i <span class="string">'3,6s/me/you/g'</span> file-name</span><br></pre></td></tr></table></figure>
<p><strong>指定每一行替换的个数</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 替换每一行的第一个匹配</span></span><br><span class="line">sed -i <span class="string">'s/me/you/1'</span> file-name</span><br><span class="line"></span><br><span class="line"><span class="comment">#替换每一行的第2个匹配</span></span><br><span class="line">sed -i <span class="string">'s/me/you/2'</span> file-name</span><br><span class="line"></span><br><span class="line"><span class="comment">#替换第5个以后的所有匹配</span></span><br><span class="line">sed -i <span class="string">'s/me/you/3g'</span> file-name</span><br></pre></td></tr></table></figure>
<h3 id="多个匹配"><a href="#多个匹配" class="headerlink" title="多个匹配"></a>多个匹配</h3><p>如果要对一行进行两个匹配，可以在命令字符串中使用;分割多个匹配项：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed &apos;1,3s/me/you/g; 3,$s/you/me/g&apos; file-name</span><br><span class="line"># 下面的命令等效</span><br><span class="line">sed -e &apos;1,3s/me/you/g&apos; -e &apos;3,$s/you/me/g&apos; file-name</span><br></pre></td></tr></table></figure>
<p>这样将1-3行的me替换为you，将3到最后一行的you替换为me。</p>
<h3 id="圆括号匹配"><a href="#圆括号匹配" class="headerlink" title="圆括号匹配"></a>圆括号匹配</h3><p>类似于正则表达式中的分组，在s中使用的括号，可以在替换串中使用\1,\2指代<br>比如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed <span class="string">'s/This is your \([^,]*\),.*is \(.*\)/\1,\2/g'</span> cats.txt</span><br></pre></td></tr></table></figure>
<p>注意括号部分表示匹配项，括号需要使用斜杠<code>\</code>转义。这与一些编程语言中的规约不一样，一般来说使用$1, $2来指代匹配项。</p>
<h2 id="sed的命令"><a href="#sed的命令" class="headerlink" title="sed的命令"></a>sed的命令</h2><p>sed工具有一些工具用来操作文本，比如在指定行插入行:</p>
<h3 id="a-i-命令"><a href="#a-i-命令" class="headerlink" title="a/i 命令"></a>a/i 命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 在第一行后追加一行</span><br><span class="line">sed &quot;1 a This is your mou, you mou&apos;s name is miaomiao&quot; cats.txt</span><br><span class="line">// 在第一行插入一行，即原来的第一行成为第二行</span><br><span class="line">sed &quot;1 i this is ****&quot; cats.txt</span><br><span class="line">//在文件结尾追加一行</span><br><span class="line">sed &quot;$ a this is ****&quot; cats.txt</span><br><span class="line">// 在所有匹配行后追加一行</span><br><span class="line">sed &quot;/my/a this is my ***&quot; cats.txt</span><br></pre></td></tr></table></figure>
<h3 id="c命令替换匹配行"><a href="#c命令替换匹配行" class="headerlink" title="c命令替换匹配行"></a>c命令替换匹配行</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//替换第二行</span><br><span class="line">sed &quot;c 2 this is my****&quot; cats.txt</span><br><span class="line">// 替换匹配行</span><br><span class="line">sed /my/c this is your****&quot; cats.txt</span><br></pre></td></tr></table></figure>
<h3 id="d命令删除匹配行"><a href="#d命令删除匹配行" class="headerlink" title="d命令删除匹配行"></a>d命令删除匹配行</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 删除第二行</span><br><span class="line">sed &apos;2s&apos; cats.txt</span><br><span class="line">// 删除从第3行到结尾</span><br><span class="line">sed &apos;3,$d&apos; cats.txt</span><br></pre></td></tr></table></figure>
<h3 id="p命令打印输出"><a href="#p命令打印输出" class="headerlink" title="p命令打印输出"></a>p命令打印输出</h3><p>使用p有点类似grep命令，把匹配行输出</p>
<h2 id="处理目录下所有文件"><a href="#处理目录下所有文件" class="headerlink" title="处理目录下所有文件"></a>处理目录下所有文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed -i &apos;2,$s/\t/,\t/g&apos; *</span><br></pre></td></tr></table></figure>
<p>还可以结合grep命令筛选需要处理的文件,这是替换文件内容包含 pattern 的文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed -i &apos;command&apos; `grep -rl pattern ./`</span><br></pre></td></tr></table></figure>
<p>grep的l参数表示只输出文件名，r表示recursive</p>
<p>也可以结合 ls 对文件名筛选：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed -i &apos;command&apos; `ls | grep .txt`</span><br></pre></td></tr></table></figure>
<p>这样就只对 txt 文件执行替换。</p>
<h2 id="待续"><a href="#待续" class="headerlink" title="待续"></a>待续</h2>
            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/example-of-awk-handle-csv/" itemprop="url">
                  一个使用awk处理csv数据示例
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-08-19T12:34:50+08:00" content="2015-08-19">
              2015-08-19
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>最近要处理一个csv文件，起始是这样的：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>mmid</th>
<th>cp</th>
</tr>
</thead>
<tbody>
<tr>
<td>zy006</td>
<td>2200112411</td>
<td>小米商城</td>
</tr>
<tr>
<td>zy007</td>
<td>2200123091-3003904564</td>
<td>掌游自有渠道</td>
</tr>
<tr>
<td>zy008</td>
<td>0</td>
<td>MM应用商城</td>
</tr>
<tr>
<td>zy101</td>
<td>2200131184-2200131784</td>
<td>多酷</td>
</tr>
<tr>
<td>zy102</td>
<td>2200017122-2200126498-2200127284-3003898651</td>
<td>3G门户</td>
</tr>
<tr>
<td>zy104</td>
<td>3003904473</td>
<td>软吧</td>
</tr>
</tbody>
</table>
<p>第二列是多个元素组合起来的，现在要导入到数据库里面，把第一列和第二列的元素使用一个关联表而不是这样使用数据拼接的方式。</p>
<p>要处理的结果是抽出第一列和第二列，然后第二列使用’-‘分割新建一条记录。</p>
<p>步骤如下：</p>
<p>1 抽出数据到新文件:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk -F <span class="string">","</span> <span class="string">'NR&gt;1&#123;printf("%s,%s\n", $1, $2)&#125;'</span> data.csv&gt; mmid.csv</span><br></pre></td></tr></table></figure>
<p>NR代表当前的记录的数值，表示第几个记录了，这里忽略掉第一行。</p>
<p>2 分割数据并创建新记录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk -F <span class="string">'[,-]'</span> <span class="string">'&#123;for(i=2;i&lt;NF;i++) &#123;printf("%s,%s\n", $1, $i)&#125;&#125;'</span> mmid.csv &gt; channel_mmid.csv</span><br></pre></td></tr></table></figure>
<p>使用-F 设置两个分割参数，使用一个循环，其中NF是number of fields的简写，表名当前当有多少条记录，对应有NR，number of record</p>
<p>3 完成</p>
<p>使用awk处理excel/csv文件真的非常的方便</p>
<p>4 扩展</p>
<p>删除记录中的某一列</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk -F <span class="string">','</span> <span class="string">'BEGIN&#123;OFS=","; &#125; NR&gt;1&#123;str=""; for (i=1; i&lt;=NF;i++) if (i != 2) str = str "," $i; print str&#125;'</span> channel-manage.csv &gt; new-channel-manage.csv</span><br></pre></td></tr></table></figure>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/write-your-first-php-extension/" itemprop="url">
                  编写你的第一个PHP扩展模块(一)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-08-18T12:34:50+08:00" content="2015-08-18">
              2015-08-18
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/programming/" itemprop="url" rel="index">
                    <span itemprop="name">programming</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>一直以来对于PHP的扩展编写都比较感兴趣但是却没有什么更深的接触，正好最近要研究一下，做个记录吧。</p>
<p>参考：<br><a href="http://www.laruence.com/2009/04/28/719.html" title="http://www.laruence.com/2009/04/28/719.html" target="_blank" rel="noopener">http://www.laruence.com/2009/04/28/719.html</a><br><a href="http://www.walu.cc/phpbook/5.md" title="http://www.walu.cc/phpbook/5.md" target="_blank" rel="noopener">http://www.walu.cc/phpbook/5.md</a></p>
<p>首先我们从头安装一个PHP环境，现在最新的稳定版的PHP是5.6.12。</p>
<h2 id="编译安装php"><a href="#编译安装php" class="headerlink" title="编译安装php"></a>编译安装php</h2><p>以下在Linux（centos）下完成</p>
<ol>
<li>下载src： <code>wget http://cn2.php.net/get/php-5.6.12.tar.bz2/from/this/mirror</code> wget 下载的文件可能被命名为mirror，需要重命名一下 <code>mv mirror php-5.6.12.tar.bz2</code></li>
<li>解压： <code>tar xjvf php-5.6.12.tar.bz2</code></li>
<li><code>cd php-5.6.12</code> 编译安装： <code>./configure --prefix=/home/wuxu/data/php5.6/ --enable-debug --enable-maintainer-zts</code></li>
<li><code>make</code></li>
<li><code>make install</code></li>
<li><code>make clean</code></li>
</ol>
<p>这样一个新的php安装在了家目录下（/home/wuxu/data/php5.6）。</p>
<h2 id="扩展的准备工作"><a href="#扩展的准备工作" class="headerlink" title="扩展的准备工作"></a>扩展的准备工作</h2><p>首先要理解为PHP内核编写的扩展的两个工作方式，一种是编译为动态共享对象/可装载模块，也就是常见的.so扩展，这种扩展可以在php的配置文件中方便的开启或者关闭；另外一种方式是静态编译到PHP中，使用静态方法编译比较容易上手，鸟哥的文章中也是使用的静态编译方式，所以我们也使用静态编译方式来练习。</p>
<p>PHP在源码中提供了一个扩展骨架构造脚本： ext_skel，脚本放在php-5.6.12/ext目录下。它的使用方式如下： </p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">./ext_skel --extname=mfs --proto=mfs.def</span><br></pre></td></tr></table></figure>
<p>解释一下，–extname明显就是我们要创建的扩展的名称，–proto的proto是prototype的缩写，也就是扩展对外提供的函数原型，可以在这个文件中添加要导出的函数签名，每个函数做一行，这样ext_skel脚本可以自动创建它们的骨架代码。比如鸟哥的例子中的字符串复制函数:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string self_concat(string str, int n)</span><br></pre></td></tr></table></figure>
<p>把这一行保存为mfs.def文件，放在ext文件夹下。</p>
<h2 id="基本骨架"><a href="#基本骨架" class="headerlink" title="基本骨架"></a>基本骨架</h2><p>运行上面的ext_skel命令，就会在ext文件夹下创建一个mfs的文件夹，并声称一些代码文件和配置文件。 php扩展在Linux下的配置文件是 ext/mfs/config.m4；m4有自己的语法，不过我们并不需要熟悉它，只需要简单去掉一些注释就可以了。打开配置文件config.m4；大概在16行和18行，找到<code>PHP_ARG_ENABLE(mfs, whether to enable mfs support</code> 相关的内容，这一行是用来重新生成configure文件时起作用的，取消这一行及<br>它后面的第二行<code>[ --enable-myfunctions                Include myfunctions support])</code>，中间有一行不要取消注释。这样就可以重新生成configure文件可以使用enable-mfs来静态编译扩展。</p>
<p>完成上面的工作后，重新生成configure文件并编译安装php。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /path/to/php-5.6.12</span><br><span class="line">./buildconf --force</span><br><span class="line">./configure --enable-fms --prefix=/home/wuxu/data/php5.6 --with-config-file-path=/home/wuxu/data/etc/php.ini</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>这样编译的php就带有了fms扩展，并可以使用在def文件中定义的原型函数。但是由于并没有编写那个函数的具体内容，所以这个是str_concat函数并不能起作用，不过ext_skel脚本还导出了一个函数： confirm_mfs_compiled(str); 可以用下面的脚本检测fms扩展是否可用了：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">print</span> confirm_mfs_compiled(<span class="string">"myextension"</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// output: </span></span><br><span class="line"><span class="comment">// "Congratulations! You have successfully modified ext/mfs</span></span><br><span class="line"><span class="comment">//  </span></span><br><span class="line"><span class="comment">// config.m4. Module mfs is now compiled into PHP."</span></span><br></pre></td></tr></table></figure>
<p>表明脚本已经编译到php了。下面我们就可以开始编写self_concat的具体内容了。</p>
<h2 id="起始代码"><a href="#起始代码" class="headerlink" title="起始代码"></a>起始代码</h2><p>先看一下有ext_skel脚本自动生成的self_concat函数代码，在ext/mfs/mfs.c:76 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PHP_FUNCTION(self_concat)</span><br><span class="line">&#123;</span><br><span class="line">	char *str = NULL;</span><br><span class="line">	int argc = ZEND_NUM_ARGS();</span><br><span class="line">	int str_len;</span><br><span class="line">	long n;</span><br><span class="line">	if (zend_parse_parameters(argc TSRMLS_CC, &quot;sl&quot;, &amp;str, &amp;str_len, &amp;n) == FAILURE)</span><br><span class="line">		return;</span><br><span class="line">	php_error(E_WARNING, &quot;self_concat: not yet implemented&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些代码是一个到处函数的基本框架了。<br>使用PHPFUNCTION()宏来生成一个适合于Zend引擎的函数原型。其中比较重要的是 zend_parse_parameters 函数，用来获取函数传递的参数；该函数的原型是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">zend_parse_parameters(<span class="keyword">int</span> num_args TSRMLS_DC, <span class="keyword">char</span> *type_spec, …);</span><br></pre></td></tr></table></figure>
<p>第一个参数是参数的个数，通常使用<code>ZEND_NUM_ARGS()</code>的返回值，TSRMLS_DC这个照写就可以了，第三个参数比较复杂是一个表示函数期望的参数类型的字符串，后面紧跟参数值的变量列表，这里有一个PHP的松散变量和动态类型推断到C语言类型的转换。</p>
<p>第三个参数根据一个参数类型对照表生成:</p>
<table>
<thead>
<tr>
<th>类型指定符</th>
<th>对应的C类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>l</td>
<td>long</td>
<td>符号整数</td>
</tr>
<tr>
<td>d</td>
<td>double</td>
<td>浮点数</td>
</tr>
<tr>
<td>s</td>
<td>char *, int</td>
<td>二进制字符串，长度</td>
</tr>
<tr>
<td>b</td>
<td>zend_bool</td>
<td>逻辑型（1或0）</td>
</tr>
<tr>
<td>r</td>
<td>zval *</td>
<td>资源（文件指针，数据库连接等）</td>
</tr>
<tr>
<td>a</td>
<td>zval *</td>
<td>联合数组</td>
</tr>
<tr>
<td>o</td>
<td>zval *</td>
<td>任何类型的对象</td>
</tr>
<tr>
<td>O</td>
<td>zval *</td>
<td>指定类型的对象。需要提供目标对象的类类型</td>
</tr>
<tr>
<td>z</td>
<td>zval *</td>
<td>无任何操作的zval</td>
</tr>
</tbody>
</table>
<p>考虑上面代码的实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (zend_parse_parameters(argc TSRMLS_CC, &quot;sl&quot;, &amp;str, &amp;str_len, &amp;n) == FAILURE)</span><br><span class="line">	return;</span><br></pre></td></tr></table></figure>
<p>“sl”: 第一个字符s代表二进制字符串，它在后面的参数列表中对应两个值，一个 &amp;str， 一个&amp;strlen；第二个字符’l’（L的小写）,表示整数类型参数对应 &amp;n。</p>
<blockquote>
<p>扩展中的字符串都是二进制字符串，即并不以\0作为字符串结束，而是使用一个str_len表示字符串长度，具体看_zval结构体。</p>
</blockquote>
<p>下面的工作就是修改这个函数了。</p>
<h2 id="完成第一个导出函数"><a href="#完成第一个导出函数" class="headerlink" title="完成第一个导出函数"></a>完成第一个导出函数</h2><p>将自动生成的函数更新为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PHP_FUNCTION(self_concat)</span><br><span class="line">&#123;</span><br><span class="line">	char *str = NULL;</span><br><span class="line">	int argc = ZEND_NUM_ARGS();</span><br><span class="line">	int str_len;</span><br><span class="line">	long n;</span><br><span class="line">	char *result; /* Points to resulting string */</span><br><span class="line">	char *ptr; /* Points at the next location we want to copy to */</span><br><span class="line">	int result_length; /* Length of resulting string */</span><br><span class="line">	</span><br><span class="line">	if (zend_parse_parameters(argc TSRMLS_CC, &quot;sl&quot;, &amp;str, &amp;str_len, &amp;n) == FAILURE) &#123;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	result_length = (str_len * n);</span><br><span class="line">	result = (char *) emalloc(result_length + 1);</span><br><span class="line">	ptr = result;</span><br><span class="line">	while (n--) &#123;</span><br><span class="line">		memcpy(ptr, str, str_len);</span><br><span class="line">		ptr += str_len;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	*ptr = &apos;\0&apos;;</span><br><span class="line"></span><br><span class="line">	RETURN_STRINGL(result, result_length, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按照上面的方法，重新编译php， 就可以在php文件中直接使用slef_concat()函数拼接字符串了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">print self_concat(&quot;pop_&quot;, 10);</span><br></pre></td></tr></table></figure>
<p>保存为confirm.php;运行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">php confirm.php</span><br></pre></td></tr></table></figure>
<p>会输出拼接的字符串了。</p>
<h2 id="待续"><a href="#待续" class="headerlink" title="待续"></a>待续</h2>
            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    

  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/14/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><span class="page-number current">15</span><a class="page-number" href="/page/16/">16</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><a class="extend next" rel="next" href="/page/16/"><i class="fa fa-angle-right"></i></a>
  </nav>



        </div>

        


        

      </div>

      
        
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="/images/avatar.jpg" alt="wuxu" itemprop="image"/>
          <p class="site-author-name" itemprop="name">wuxu</p>
        </div>
        <p class="site-description motion-element" itemprop="description">Wu Xu的个人博客</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">173</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">24</span>
              <span class="site-state-item-name">分类</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">145</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/wuxu92" target="_blank">
                  
                    <i class="fa fa-github"></i> GitHub
                  
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/wuxu92" target="_blank">
                  
                    <i class="fa fa-twitter"></i> Twitter
                  
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/kiwidock" target="_blank">
                  
                    <i class="fa fa-weibo"></i> Weibo
                  
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://douban.com/people/wuxu92" target="_blank">
                  
                    <i class="fa fa-douban"></i> Douban
                  
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.zhihu.com/people/wuxu92" target="_blank">
                  
                    <i class="fa fa-zhihu"></i> Zhihu
                  
                </a>
              </span>
            
          
        </div>

        
        
          <div class="cc-license motion-element" itemprop="license">
            <a href="http://creativecommons.org/licenses/by-nc-sa/4.0" class="cc-opacity" target="_blank">
              <img src="/images/cc-by-nc-sa.svg" alt="Creative Commons" />
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


      
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2014 - 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="icon-next-heart fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wuxu</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  

  
    
    

  


  

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.2"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.2"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
<script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

<script type="text/javascript" src="/js/motion.js?v=0.4.5.2" id="motion.global"></script>


  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  

  <script type="text/javascript" src="/js/bootstrap.js"></script>

  
  

  
  

</body>
</html>
