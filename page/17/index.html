<!doctype html>
<html class="theme-next ">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="google-site-verification" content="h7BaHlqi6VjlciSt0RF-KHgIXZcGfx3L3gyQ9qfx_ek" />










  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.4.5.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="wuxu, Golang, C, CPP, CS, PHP, " />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.2" />






<meta name="description" content="Wu Xu的个人博客">
<meta property="og:type" content="website">
<meta property="og:title" content="Wu Xu">
<meta property="og:url" content="http://blog.wuxu92.com/page/17/index.html">
<meta property="og:site_name" content="Wu Xu">
<meta property="og:description" content="Wu Xu的个人博客">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Wu Xu">
<meta name="twitter:description" content="Wu Xu的个人博客">



<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: '',
    sidebar: 'hide',
    motion: false
  };
</script>

  <title> Wu Xu </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-72131273-1', 'auto');
  ga('send', 'pageview');
</script>





  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>
    <div class="bottomband"></div> <!-- add by wuxu -->
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Wu Xu</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">关注C、Go、C++、JavaScript和Rust</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th fa-fw"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-user fa-fw"></i> <br />
            
            关于
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content">
          
  <section id="posts" class="posts-expand">

    

    
    

    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/nsq-basic/" itemprop="url">
                  nsq实时消息服务的TCP协议规范
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-07-28T12:34:50+08:00" content="2015-07-28">
              2015-07-28
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/tools/" itemprop="url" rel="index">
                    <span itemprop="name">tools</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>NSQ是使用golang开发的实时分布式消息处理平台，由bit.ly开源的项目，可以用来处理每天十亿级别的消息。</p>
<p>由于nsq可以直接编译为可执行的二进制文件的特性，nsq的安装非常简单，下载二进制包解压就可以运行了。 参考<a href="http://nsq.io/deployment/installing.html" title="http://nsq.io/deployment/installing.html" target="_blank" rel="noopener">官方文档</a></p>
<p>快速运行也很简单依次在终端中启动nsq的服务即可。这里也不细说了，参考： <a href="http://nsq.io/overview/quick_start.html" target="_blank" rel="noopener">http://nsq.io/overview/quick_start.html</a></p>
<p>关于nsq的几个组件会在后面记一篇，现在主要学习一些nsq中使用的TCP协议规范。</p>
<blockquote>
<p>NSQ的协议足够简单，任何语言编译客户端都很容易。</p>
</blockquote>
<p><strong>nsqd进程通过监听配置的TCP端口来接受客户端连接</strong></p>
<p><strong>对nsq的用途理解有点错误了</strong></p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/litle-known-css-facts/" itemprop="url">
                  那些你可能不知道但是很有意思的CSS Tricks
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-07-27T12:34:50+08:00" content="2015-07-27">
              2015-07-27
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/fe/" itemprop="url" rel="index">
                    <span itemprop="name">fe</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>在去年的时候，Louis Lazaris在sitepoint上发了一篇文章 [http</p>
<p>参考：<br><a href="http://www.sitepoint.com/12-little-known-css-facts/" target="_blank" rel="noopener">12 Little-Known CSS Facts</a><br><a href="http://www.sitepoint.com/12-little-known-css-facts-the-sequel/" target="_blank" rel="noopener">12 Little-Known CSS Facts (The Sequel)</a></p>
<p>CSS 本身并不是非常复杂的语言，但是即使你写过很多的CSS样式，你总会感觉到对它并不了解，使用了很多年之后你还是会偶遇很多你没有用过的“有意思”的样式属性，本文作者列举了一些这样的Tricks。</p>
<h2 id="color属性不只是作用域文本"><a href="#color属性不只是作用域文本" class="headerlink" title="color属性不只是作用域文本"></a>color属性不只是作用域文本</h2><p>color属性大家都很熟悉，一般用来设置文本(Text)的颜色属性，但是如果你把body标签的color设置为某种颜色，比如<code>color: yellow</code>几乎所有的东西就都会变成黄色的，包括图片的替代文本，列表的bullet，border等，但是<code>hr</code>标签并不会默认继承这个颜色，需要手动设置 <code>border-color: inherit</code>才会变成黄色。<br>color属性的spec中是这么定义的：</p>
<blockquote>
<p>This property describes the foreground color of an element’s text<br>content. In addition it is used to provide a potential indirect value<br>… for any other properties that accept color values.</p>
</blockquote>
<h2 id="visibility属性可以设置为”collapse”"><a href="#visibility属性可以设置为”collapse”" class="headerlink" title="visibility属性可以设置为”collapse”"></a>visibility属性可以设置为”collapse”</h2><p>所有元素的visibility属性的默认值都是<code>visible</code>, 我们可以把它设置为<code>hidden</code>来隐藏一个元素，与<code>dispaly: none</code>表现不同的是，hidden的元素仍然会占据原来的空间（still occupy space）<br>visibility属性还有一个值就是<code>collapse</code>，它的表现一般和<code>hidden</code>是一样的，但是在table中表现会不一样，可能你已经想到了，在table元素中的行，行组，列，列组中使用<code>collapse</code>属性它的表现和<code>display:none</code>是一样的。<br><strong>不过用于浏览器对这个属性的表现并不一致，所以还是<a href="http://css-tricks.com/almanac/properties/v/visibility/" target="_blank" rel="noopener">不要使用</a>了</strong></p>
<h2 id="background属性有了新的内容"><a href="#background属性有了新的内容" class="headerlink" title="background属性有了新的内容"></a>background属性有了新的内容</h2><p>在CSS 2.1中，background属性有color, image, repeat, attachment, position 5个“子内容”，在CSS3 中，添加很了一些新内容：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">background</span>: <span class="selector-attr">[background-color]</span> <span class="selector-attr">[background-image]</span> <span class="selector-attr">[background-repeat]</span></span><br><span class="line">            [background-attachment] [background-position] / [ background-size]</span><br><span class="line">            <span class="selector-attr">[background-origin]</span> <span class="selector-attr">[background-clip]</span></span><br></pre></td></tr></table></figure>
<p>一个示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.example &#123;</span><br><span class="line">  background: aquamarine url(img.png)</span><br><span class="line">	no-repeat</span><br><span class="line">	scroll</span><br><span class="line">	center center / 50%</span><br><span class="line">	content-box content-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些新属性在所有现代浏览器都能正常工作，只不过好像用处也不大。</p>
<h2 id="clip属性只在绝对定位元素上起作用"><a href="#clip属性只在绝对定位元素上起作用" class="headerlink" title="clip属性只在绝对定位元素上起作用"></a>clip属性只在绝对定位元素上起作用</h2><p>clip属性可以用来对元素进行裁剪，它的值是一个图形，比如rect，或者是auto。<br>但是要注意，clip属性只对决定定位元素起作用，包括<code>position: absolute;</code>,和<code>position: fixed</code>两种情况。<br>使用:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.example</span> &#123;</span><br><span class="line">	<span class="attribute">position</span>: absolute;</span><br><span class="line">	<span class="attribute">clip</span>: <span class="built_in">rect</span>(110px, 160px, 170px, 60px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它的表现可以参考这张图片: <img src="http://cdn.impressivewebs.com/2012-05/clip-visual.jpg" alt=""><br>更多关于clip的内容，可以查看<a href="http://www.impressivewebs.com/css-clip-property/" target="_blank" rel="noopener">这里</a></p>
<h2 id="垂直百分比和容器的宽度有关而不是高度"><a href="#垂直百分比和容器的宽度有关而不是高度" class="headerlink" title="垂直百分比和容器的宽度有关而不是高度"></a>垂直百分比和容器的宽度有关而不是高度</h2><p>这个听起来有点奇怪，我们知道百分比计算宽度是基于容器的宽度的，但是实际上padding-top, margin-top, padding-bottom, margin-bottom这些属性的百分比属性也是基于容器的宽度的，而不是高度。<br>这是挺有意思的。</p>
<h2 id="border属性-is-Kind-of-Like-Inception"><a href="#border属性-is-Kind-of-Like-Inception" class="headerlink" title="border属性 is Kind of Like Inception"></a>border属性 is Kind of Like Inception</h2><p>border属性我们会经常使用，比如这样子：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.somecontainer</span> &#123;</span><br><span class="line">	<span class="attribute">border</span>: solid <span class="number">1px</span> black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们知道border属性是border-style, border=width, border-color三个属性的综合声明。但是其实这三个属性都可以对上下左右四条边分别设置属性：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.somecontainer</span> &#123;</span><br><span class="line">	<span class="attribute">border-width</span>: <span class="number">2px</span> <span class="number">5px</span> <span class="number">1px</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样可以把border设置的很复杂，不过在实际使用中，并不要这么用，因为这样使得整个元素显得混乱而导致页面风格混乱。</p>
<h2 id="text-decoration-现在也成为了一种速记符（shorthand）"><a href="#text-decoration-现在也成为了一种速记符（shorthand）" class="headerlink" title="text-decoration 现在也成为了一种速记符（shorthand）"></a>text-decoration 现在也成为了一种速记符（shorthand）</h2><p>新的css规范中，可以这样使用text-decoration属性：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">	<span class="attribute">text-decoration</span>: overline aqua wavy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个值是<code>text-decoration-line</code>, 第二个是<code>text-decoration-color</code>, 第三个是 <code>text-dcoration-style</code>属性<br>不过这个属性只在firefox中实现了。</p>
<h2 id="border-width属性可以接受关键字值"><a href="#border-width属性可以接受关键字值" class="headerlink" title="border-width属性可以接受关键字值"></a>border-width属性可以接受关键字值</h2><p>现在border-width 可以接受 <code>medium</code>, <code>thin</code>, <code>thick</code>关键字了。他们在浏览器实现中大概是1px, 2px, 5px;不过在spec中并没有指定他们具体的值。</p>
<h2 id="几乎没人使用botder-image"><a href="#几乎没人使用botder-image" class="headerlink" title="几乎没人使用botder-image"></a>几乎没人使用botder-image</h2><p><code>border-image</code>看起来是个不错的属性，使某些表现变得整洁，有一个特别经典的例子是在一圈文字的border加一圈花or狗爪印？不过在现实中几乎没有人会使用这个属性，我也没有使用过。。</p>
<h2 id="empty-cells属性"><a href="#empty-cells属性" class="headerlink" title="empty-cells属性"></a>empty-cells属性</h2><p>这个属性被所有主流浏览器支持，包括IE8。它的用法如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">table</span> &#123;</span><br><span class="line">	<span class="attribute">empty-cell</span>: hide;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个属性用于table元素中空td的样式。或许会有用哦。 测试： <a href="http://codepen.io/SitePoint/pen/yfhtq" target="_blank" rel="noopener">codepen</a></p>
<h2 id="font-style属性接受“oblique”值"><a href="#font-style属性接受“oblique”值" class="headerlink" title="font-style属性接受“oblique”值"></a>font-style属性接受“oblique”值</h2><p>这个看起来和 <code>font-style: italic</code> 并没有什么区别，都是斜体字体，spec中是这么描述的：</p>
<blockquote>
<p>“…selects a font that is labeled as an oblique face, or an italic face if one is not.”</p>
</blockquote>
<p>如果设置的字体没有真正的italic样式（face），那么<code>font-style:italic</code> 和 <code>font-style: oblique</code>的表现是一样的。</p>
<h2 id="word-wrap-属性和overflow-wrap属性是一样的"><a href="#word-wrap-属性和overflow-wrap属性是一样的" class="headerlink" title="word-wrap 属性和overflow-wrap属性是一样的"></a>word-wrap 属性和overflow-wrap属性是一样的</h2><p><code>word-wrap</code>是微软提出的一个属性，所以在IE老版本中都有很好的支持，但是W3C决定使用<code>overflow-wrap</code> 替换掉 <code>word-wrap</code>。但是现在所有的浏览器都支持 <code>word-wrap</code>属性了，所以要替换也不是那么容易的事了。</p>
<p>没什么问题的话还是继续使用<code>word-wrap</code>吧。</p>
<h2 id="待续"><a href="#待续" class="headerlink" title="待续"></a>待续</h2>
            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/notes-of-go-by-example/" itemprop="url">
                  Go by Example 中值得注意的点(一)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-07-27T12:34:50+08:00" content="2015-07-27">
              2015-07-27
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Programming/" itemprop="url" rel="index">
                    <span itemprop="name">Programming</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <h2 id="不定参数"><a href="#不定参数" class="headerlink" title="不定参数"></a>不定参数</h2><p>不定参数的用法已经知道了，函数可以定义如下：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span> <span class="params">(nums ...<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">	total := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">		total += num</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> total</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样可以计算任意个传入的int参数的和，但是有下面的用法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nums := []int&#123;1,2,3,4,5&#125;</span><br><span class="line">t := sum(nums...)</span><br></pre></td></tr></table></figure>
<p><code>nums...</code> 这样的用法在之前没有遇到过，它可以用来表示， 将一个slice的元素作为函数的实参列表。</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>对于使用过js的人，闭包是一个非常熟悉的概念了。js使用闭包实现内部变量的私有化，go中也有同样的目的？<br>与js不同的是在定义函数的地方要把返回值写明返回的函数的签名。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">intSeq</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	i := <span class="number">0</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">		i += <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> i</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样定义的intSeq函数调用后的返回值就是一个函数。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">next := intSeq()</span><br><span class="line"><span class="comment">// next是一个命名函数了</span></span><br><span class="line">next()</span><br></pre></td></tr></table></figure>
<p>相比js的闭包，功能不是那么丰富，不过本质差不多。</p>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>Go提供了指针支持，允许传递值的引用。函数的参数可以是某种类型的指针。比如：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">zeroptr</span><span class="params">(i *<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	*i = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">i := <span class="number">1</span></span><br><span class="line">zeroptr(&amp;i)</span><br></pre></td></tr></table></figure>
<p>对于指针要理解星号（*）符号和引用符号（&amp;）的作用。</p>
<blockquote>
<p>Assigning a value to a dereferenced pointer changes the value at the referenced address.</p>
</blockquote>
<p>语法 <code>&amp;i</code>得到的是<code>i</code>的内存地址，也就是i的指针。也可能存在指向指针的指针。在函数体内部，<code>*i</code>将指针/内存地址 <em>解引用(dereferendes)</em>为地址指向的值。所以赋值语句为<code>*i=0</code>这中形式。</p>
<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>go中使用关键字struct定义结构体，和C语言的结构体非常相似，不过相比C语言要简单很多了，没有C语言那些复杂的指针维护。<br>结构体可以使用字面量初始化：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个结构</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">me := Person&#123;<span class="string">"wuxu"</span>, <span class="number">22</span>&#125;</span><br><span class="line">anotherMe := Person&#123;name:<span class="string">"wuxu"</span>, age:<span class="number">22</span>&#125;</span><br><span class="line">mePtr := &amp;me</span><br></pre></td></tr></table></figure>
<p>还是要注意指针的理解， me是一个对象， &amp;me返回的是对象的地址，复制给 mePtr， 如果要将mePtr的内存存放新的对象应该如下:</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">*mePtr = Person&#123;<span class="string">"new Name"</span>, <span class="number">33</span>&#125;</span><br><span class="line"><span class="comment">// 错误: mePtr =  Person&#123;"new name", 33&#125;</span></span><br></pre></td></tr></table></figure>
<p>修改了mePtr的对象，me的对象也被修改了，因为他们是同一片内存区域。</p>
<h2 id="方法（method）"><a href="#方法（method）" class="headerlink" title="方法（method）"></a>方法（method）</h2><p>我们知道在Go中可以给struct“绑定”方法，其实现方式如下:</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">say</span><span class="params">(words <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	fmt.Println(p.name, <span class="string">"says: "</span>, words)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span> <span class="title">run</span><span class="params">(d <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	fmt.Println(p.name, <span class="string">" runs away "</span>, d, <span class="string">" meters"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面给Person结构体绑定了两个方法，看以看到，方法绑定中，一个使用 <code>Person</code> ,一个是 <code>*Person</code>他们有什么区别呢？<br>在方法调用时，Go会自动处理变量和指针的转换，即下面的调用时正确的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">me := Person(&quot;wuxu&quot;, 22)</span><br><span class="line">me.say(&quot;wtf&quot;)</span><br><span class="line">me.run(100)</span><br></pre></td></tr></table></figure>
<p>虽然run方法的参数类型是 <code>*Person</code>，使用me调用也能正确执行，那么在绑定参数时的<code>*</code>有什么作用？ 这里其实和值与引用相似。不带<code>*</code>的参数相当于值传递，带<code>*</code>的相当于引用传递，所以在say方法中对p的属性修改不会改变调用者的值，而在run方法中修改p的属性会表现在调用者上。</p>
<blockquote>
<p>Go automatically handles conversion between values and pointers for method calls. You may want to use a pointer receiver type to avoid copying on method calls or to allow the method to mutate the receiving struct.</p>
</blockquote>
<p>但是要注意，如果使用 <code>*</code>的话，方法便不再是绑定在Person结构体上了，而是在<code>*Person</code>上了。<br>虽然Person的对象也能调用，这在接口实现中会有表现： 如果一个接口定义了run方法，那么实现这个接口的struct绑定方法时，不能使用<code>*</code></p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>Go的接口，只要定义的类型“绑定”了接口中定义的方法，就认为类型实现了接口。没有implements这类的显式声明实现接口。</p>
<p>一个接口实现的示例：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> animal <span class="keyword">interface</span> &#123;</span><br><span class="line">  run(<span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Pig <span class="keyword">struct</span> &#123;</span><br><span class="line">  name <span class="keyword">string</span></span><br><span class="line">  age <span class="keyword">int</span>                                    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Pig)</span> <span class="title">run</span><span class="params">(d <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">"Pig runs away "</span>, d)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runAway</span><span class="params">(an animal)</span></span> &#123;</span><br><span class="line">  an.run(<span class="number">100</span>);</span><br><span class="line">&#125;                                  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inters</span><span class="params">()</span></span> &#123;</span><br><span class="line">  runAway(Person&#123;<span class="string">"TM"</span>, <span class="number">22</span>, <span class="literal">false</span>&#125;)</span><br><span class="line">  runAway(Pig&#123;<span class="string">"wangcai"</span>, <span class="number">1</span>&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于接口的更多内容可以查看 <a href="http://jordanorelli.com/post/32665860244/how-to-use-interfaces-in-go" title="http://jordanorelli.com/post/32665860244/how-to-use-interfaces-in-go" target="_blank" rel="noopener">这篇博客</a></p>
<h2 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h2><p>我们知道Go没有异常系统，而是通过一个显式声明的独立返回值（利用多返回值特性）来声明错误。一般在最后一个返回值声明错误。<br>error是系统提供的返回错误接口，可以自己定制类型实现该接口作为定制的错误类型返回。如果错误位返回nil表示没有错误。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e myErr)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> fmt.Sprintf(<span class="string">"%d - %s"</span>, e.arg, e.prob)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span><span class="title">buy</span><span class="params">(item <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">bool</span>, error)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> p.age &lt; <span class="number">18</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>, &amp;myErr&#123;<span class="number">0</span>, <span class="string">"too yong"</span>&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>常见的自定义错误如上，注意几点，在返回处， 需要使用 <code>&amp;myErr</code>，否则会报类型错误。如果没有自定义错误，可以直接使用内置的错误类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">return false, errors.New(&quot;too yong&quot;)</span><br></pre></td></tr></table></figure>
<p>注意，需要导入errors包。<br>使用自定义错误的好处是可以在调用出对错误做类型判断，已进行相应的处理。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_, e := me.buy(&quot;shirt&quot;)</span><br><span class="line">if me, ok := e.(*myErr); ok &#123;</span><br><span class="line">	// with myErr return, me ref to return error</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="待续"><a href="#待续" class="headerlink" title="待续"></a>待续</h2><p>见第二部分</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/use-yadr-enhancing-your-vim/" itemprop="url">
                  yadr中提供的vim快捷操作
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-07-25T12:34:50+08:00" content="2015-07-25">
              2015-07-25
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/tools/" itemprop="url" rel="index">
                    <span itemprop="name">tools</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>github上面的活跃的dotfiles项目[yadr](https</p>
<p>这里主要就是官方readme文档的 <a href="https://github.com/skwp/dotfiles/#vim---whats-included" title="https://github.com/skwp/dotfiles/#vim---whats-included" target="_blank" rel="noopener">Vim部分</a> 的记录。基本的vim操作就不详细介绍了。</p>
<p>参考： <a href="http://skwp.github.io/dotfiles/" title="http://skwp.github.io/dotfiles/" target="_blank" rel="noopener">http://skwp.github.io/dotfiles/</a></p>
<h2 id="有什么？"><a href="#有什么？" class="headerlink" title="有什么？"></a>有什么？</h2><p>yadr提供了</p>
<h2 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h2><ul>
<li><code>,z</code> 切换到前一个缓冲文件（buffer），相当于 :bp[revious]</li>
<li><code>,x</code> 切换到后一个缓冲，相当于命令行的 :bn[ext]</li>
<li><code>Alt+j</code> 和 <code>Alt+k</code> 下跳或者上跳一个函数；好像不起作用</li>
<li><code>Ctrl+o</code> 跳转到旧的指针位置，这是vim的标准快捷键，<strong>非常有用</strong></li>
<li><code>Ctrl+i</code> Ctrl+o的逆操作，也是标准按键</li>
</ul>
<h2 id="搜索与代码导航"><a href="#搜索与代码导航" class="headerlink" title="搜索与代码导航"></a>搜索与代码导航</h2><ul>
<li><code>,f</code> 跳转到类定义，需要系统安装了ctags，并创建tags file。</li>
</ul>
<blockquote>
<p>ctags是一个独立的软件，不包含在vim之中，使用yum安装即可，在项目目录下运行 <code>ctags -R .</code> 后会创建tags file，这是就可以使用跳转到定义的功能了。</p>
</blockquote>
<ul>
<li><code>,F</code> 与<code>,f</code>相同不过在新建垂直分屏（vsp）显示定义</li>
<li><code>,gf</code>或者 <code>ctrl+f</code> 跳转到光标坐在变量名对应的文件，但是在一个新的分栏中显示，这在java中比较好用</li>
<li><code>gF</code> 标准快捷键，打开文件</li>
<li><code>K</code> 搜索光标所在单词，并在quickfix窗口显示结果，这个功能需要安装silver serach, <code>sudo yum install -y the_silver_searcher</code></li>
<li><code>,K</code> 没太多用，Grep the current word up to next exclamation point (useful for ruby foo! methods)</li>
<li><code>,hl</code> 开关搜索结果的高亮，相当于 :set noh与其逆操作</li>
<li><code>,gg</code>或者<code>,ag</code>: 搜索，键入这个命令后，会出现一个输入符，在双引号中输入字符后回车会搜索包含这段字符的行</li>
<li><code>,gd</code> 搜索包含字符的函数定义， grep def,不太用</li>
<li><code>,gcf</code> grep current file的缩写，查找对本文件的引用</li>
<li><code>//</code> 清空搜索</li>
<li><code>,,w</code> <code>,&lt;Esc&gt;</code>的alias，EasyMotion，highlights jump-points on the screen and lets you type to get there</li>
<li><code>,mc</code> 多标签，这个功能和sublime中的比较像，在一个单词上面使用<code>,mc</code>会记录这个单词，然后使用<code>Ctrl-n</code>或者<code>Ctrl+p</code>选择前一个或者后一个相同的单词的，或者使用Ctrl+x跳过一个。 这个比较有用</li>
<li><code>gK</code> 打开光标所在单词同名的文档？不常用</li>
</ul>
<h2 id="文件导航"><a href="#文件导航" class="headerlink" title="文件导航"></a>文件导航</h2><ul>
<li><code>,t</code>  文件选择器，不常- 用，键入指令后可以输入字符筛选文件</li>
<li><code>,b</code> 打开缓存区的一个文件，比较常用</li>
<li><code>Cmd-Shift-M</code> 跳转到方法，Linux下好像没用。</li>
<li><code>,jm</code> jump to models,可能在rails里面比较有用</li>
<li><code>Alt+Shift+N</code> nerd tree toogle,好像没什么用</li>
<li><code>Ctrl+\</code> 在侧边栏文件树显示当前文件，和sublime的sidebar有点像</li>
<li><code>Cmd-Shift-P</code> 清空ctrlp 缓存，没用过</li>
</ul>
<h2 id="常用编辑快捷键"><a href="#常用编辑快捷键" class="headerlink" title="常用编辑快捷键"></a>常用编辑快捷键</h2><ul>
<li><code>Ctrl+space</code> 自动补全- ， Tab键</li>
<li><code>,#</code>; <code>,&quot;</code>; <code>,&#39;</code>; <code>,]</code>; <code>,)</code>; <code>,}</code>;  这些优点麻烦的样子，待补充</li>
<li><code>,.</code> 跳转到上一个编辑地点。和<code>&#39;.</code>的作用相同。</li>
<li><code>,ci</code> change inside any set of quotes/brackets/etc。其作用是删除”, {}, ()之间的字符并进入插入模式</li>
</ul>
<h2 id="多标签，多窗口，分割模式"><a href="#多标签，多窗口，分割模式" class="headerlink" title="多标签，多窗口，分割模式"></a>多标签，多窗口，分割模式</h2><ul>
<li><code>alt+n</code> - 快速跳转到指定的tab</li>
<li><code>Ctrl-h,j,k,l</code> 在分栏窗口中上下左右移动。</li>
<li><code>Q</code> 关闭当前的window，<strong>非常方便</strong></li>
<li><code>vv</code> 与 <code>Ctrl-w,v</code>一样，vertical split, 上下分栏</li>
<li><code>ss</code> 与 <code>Ctrl-w,s</code>一样，horizontal split，左右分栏</li>
<li><code>,qo</code> 打开quickfix， qo =&gt; quickfix open, <strong>有用</strong></li>
<li><code>,qc</code> 关闭quickfix,  qc =&gt; quickfix close， <strong>有用</strong>，yadr配置的vim在保存文件时会做语法检查，如果检查不通过会在quickfix窗口显示错误，并且不会自动消失，这时候也许需要 <code>,qc</code>来关闭它。</li>
</ul>
<h2 id="其它常用"><a href="#其它常用" class="headerlink" title="其它常用"></a>其它常用</h2><ul>
<li><code>Ctrl-p</code> 循环历史剪切板，这个很有用，p是粘贴，Ctrl+p会粘贴之前的剪切板内容</li>
<li><code>,yr</code> view yanking, 查看历史复制记录， <code>q</code>退出查看</li>
<li><code>crs</code>, <code>crc</code>, <code>cru</code> cr 应该是 coerce（强制）， s是snake, c是camelcase， u是UPPER，转换变量大小写下划线形式，比较有意思,可以使用<code>:help abolish</code>查看更多</li>
<li><code>:NR</code> NarrowRgn，看名字不知道是干什么的，其实是选中一段代码，然后<code>:NR</code>vim会新开一个split把选中的代码放在心的split中操作，操作完后，<code>wq</code>会把结果覆盖掉原来选中的代码。也挺有用的。</li>
<li><code>,ig</code> toggle visual indentation guids</li>
<li><code>,cf</code> 拷贝当前文件的完整路径到系统剪切板</li>
<li><code>,cn</code> 拷贝文件名</li>
<li><code>,yw</code> yw是从复制从光标位置开始到单词结束，<code>,yw</code>是在任意位置复制整个单词</li>
<li><code>,ow</code> 使用yank buffer中内容覆盖当前所在的单词，ow =&gt; overwrite</li>
<li><code>,ocf</code> 打开所有git标记为修改过的文件，在splits中打开。使用git版本控制下的文件才有用, ocf =&gt; open changed files</li>
<li><code>,w</code> 去掉尾部多余的空格，应该很有用， StripTrailingWhitespaces</li>
<li><code>sj</code> 把单行的hash表格式化为多行的</li>
<li><code>sk</code> unsplit a link 应该不怎么用</li>
<li><code>,he</code> he =&gt; html escape</li>
<li><code>,hu</code> hu =&gt; html unescape</li>
<li><code>Alt+Shift-A</code> align things, 好像没什么用</li>
<li><code>:ColorToggle</code> 顾名思义</li>
<li><code>:Gitv</code> git log browser</li>
<li><code>,hi</code>  显示当前高亮的组</li>
<li><code>,gt</code> Go Tidy， 格式化html代码</li>
<li><code>:Wrap</code> 折叠长行，这个比较有用,特别是quickfix中的提示经常跑出去了 // 好像对quickfix部分不起作用 -_-</li>
<li><code>Cmd-/</code> toggle comments,在Linux下使用alt</li>
<li><code>gcp</code> comment a paragraph</li>
</ul>
<h2 id="vim相关"><a href="#vim相关" class="headerlink" title="vim相关"></a>vim相关</h2><p><code>,vr</code> 重新加载vim， vim reload</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/z-expand-anchor-element-to-fill-parent/" itemprop="url">
                  A标签(Anchor Tag)占满父元素的实现
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-07-24T12:34:50+08:00" content="2015-07-24">
              2015-07-24
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/fe/" itemprop="url" rel="index">
                    <span itemprop="name">fe</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>A标签默认是inline元素，所以标签内容的长短决定了鼠标hover的范围，在有些时候，比如某些导航列表中，需要hover父标签（li）时能hover到a标签。</p>
<p>在制作一个API文档的侧边栏导航列表的时候，html大概是这样的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;toc-macro absolute&quot;&gt;</span><br><span class="line">&lt;ul class=&quot;toc-indentation&quot;&gt;</span><br><span class="line">  &lt;li&gt;&lt;a href=&quot;#id-1&quot;&gt;1. 绑定手机号&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;&lt;a href=&quot;#id-2&quot;&gt;2. 查询手机号码是否可以绑定&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;&lt;a href=&quot;#id-3&quot;&gt;3. 添加邮箱&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;&lt;a href=&quot;#id-4&quot;&gt;4. 检查邮箱是否可以添加&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>其他的样式就不具体写了，其实现的效果是在右侧边栏实现一个列表导航。一些主要的样式大概如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.toc-macro</span>&#123; <span class="attribute">position</span>: fixed; <span class="attribute">top</span>: <span class="number">100px</span>; &#125;</span><br><span class="line"><span class="selector-class">.toc-macro</span> <span class="selector-tag">ul</span> &#123;<span class="attribute">list-style-type</span>:none; &#125;</span><br><span class="line"><span class="selector-class">.toc-macro</span> <span class="selector-tag">a</span> &#123; <span class="attribute">text-decoration</span>: none; &#125;</span><br><span class="line"><span class="selector-class">.toc-macro</span> <span class="selector-tag">li</span> &#123; <span class="attribute">padding</span>: <span class="number">6px</span> <span class="number">8px</span> <span class="number">2px</span>;<span class="attribute">text-decoration</span>:none; &#125;</span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:hover</span> &#123; <span class="attribute">background-color</span>: <span class="number">#efefef</span>;<span class="attribute">color</span>: <span class="number">#7DB75C</span>; &#125;</span><br><span class="line"><span class="selector-class">.toc-macro</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123; <span class="attribute">background-color</span>: <span class="number">#efefef</span>;<span class="attribute">color</span>: <span class="number">#7DB75C</span>; &#125;</span><br></pre></td></tr></table></figure>
<p>其中使用了决定定位时导航不会随着滚动条而滚动，使我们在查看API文档时总是能看到这个导航。<br>这样子基本符合我们的需求了，但是有一个小小的问题，那就是鼠标放到导航上如果没有放到a链接上面，li标签会变色，但是由于鼠标没有在a上所以还是箭头的形状。。。这个小小的瑕疵需要解决一下。</p>
<p>首先我们想到的是把a标签的宽度设置到 100%：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.toc-macro a &#123; display:inline-block; width: 100%; &#125;</span><br></pre></td></tr></table></figure>
<p>但是这样似乎并没有按照我们所想的表现出来。我们需要再加一些东西，让a标签的inline-block可以把宽度填充</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.toc-macro li &#123; vertical-align: middle; line-height: 15px;&#125;</span><br></pre></td></tr></table></figure>
<p>另外还有一种实现思路那就是把div下所有标签的display属性设置为block,同时a的height设置为100%：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.toc-macro ul &#123; display: block; &#125;</span><br><span class="line">.toc-macro li &#123; display: block;&#125;</span><br><span class="line">.toc-macro a &#123; display:block; height:100%; &#125;</span><br></pre></td></tr></table></figure>
<p>这样实现应该也是可行的，不过没有测试过了。</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/golang-errors/" itemprop="url">
                  Golang中的错误处理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-07-24T12:34:50+08:00" content="2015-07-24">
              2015-07-24
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Programming/" itemprop="url" rel="index">
                    <span itemprop="name">Programming</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>Go语言提供了一套“新颖的”错误系统，与Java中的异常系统不一样，Go中没有抛出异常的概念</p>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>如果有一定面向对象语言编程经验的话，肯定会对异常/错误系统有一定的了解。如果使用Java比较多的话，一定会认为抛异常是编程语言天生的一部分，因为在Java中抛异常真的是太家常便饭，无处不在了；但是在Go语言中，根本没有异常这个东西！</p>
<p>看一段官方的QA是怎么解释这个问题的：</p>
<blockquote>
<p>We believe that coupling exceptions to a control structure, as in the try-catch-finally idiom,<strong> results in convoluted code</strong>. It also tends to encourage programmers to label too many ordinary errors, such as failing to open a file, as exceptional.</p>
<p>Go takes a different approach. For plain error handling, Go’s multi-value returns make it easy to report an error without overloading the return value. A canonical error type, coupled with Go’s other features, makes error handling pleasant but quite different from that in other languages.</p>
<p>Go also has a couple of built-in functions to signal and recover from truly exceptional conditions. The recovery mechanism is executed only as part of a function’s state being torn down after an error, which is sufficient to handle catastrophe but requires no extra control structures and, when used well, can result in clean error-handling code.</p>
</blockquote>
<p>多值返回为Go提供了一个新的错误处理机制，如果对为什么Go不提供异常体系感兴趣可以在 <a href="https://golang.org/doc/articles/defer_panic_recover.html" target="_blank" rel="noopener">这里</a> 找到更多的细节。</p>
<p>在之前文章中，已经使用过Go语言的多值返回来返回详细的错误描述。按照规定，<strong>错误的类型通常为error，这是一个内建的简单接口</strong>。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">	Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以通过实现这个接口定制错误，例如打开文件时的错误:</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> PathError <span class="keyword">struct</span> &#123;</span><br><span class="line">	Op <span class="keyword">string</span></span><br><span class="line">	Path <span class="keyword">string</span></span><br><span class="line">	Err error	<span class="comment">// 由系统调用返回</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fanc (pe *PathError) Error() <span class="keyword">string</span> &#123;</span><br><span class="line">	<span class="comment">// 返回定制的错误信息</span></span><br><span class="line">	<span class="keyword">return</span> pe.Op + <span class="string">" "</span> + pe.Path + <span class="string">": "</span> + pe.Err.Error()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>effective go中有一个示例非常有利于我们理解错误的使用,这段代码的作用是创建一个文件，如果创建失败，检查是不是磁盘空间不足，如果是则删除掉一些临时文件，再尝试创建一次：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for try:=0; try&lt;2; try++ &#123;</span><br><span class="line">	file, err := os.Create(filename)</span><br><span class="line">	if err == nill &#123;</span><br><span class="line">		return  //没有错误</span><br><span class="line">	&#125;</span><br><span class="line">	// 检查是不是空间不足</span><br><span class="line">	if e,ok := err.(*os.PathError); ok &amp;&amp; e.Err == syscall.ENOSPC &#123;</span><br><span class="line">		deleteTempFiles()  	// 删除一些临时文件</span><br><span class="line">		continue 			// 再创建一次</span><br><span class="line">	&#125;</span><br><span class="line">	return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以查看源码中PathError的实现 <a href="https://golang.org/src/os/error.go" title="https://golang.org/src/os/error.go" target="_blank" rel="noopener">https://golang.org/src/os/error.go</a></p>
<h2 id="Panic函数"><a href="#Panic函数" class="headerlink" title="Panic函数"></a>Panic函数</h2><p>函数可以通过将error作为额外的返回值来向调用者报告错误，对于一些“致命”的错误，他们导致程序不能继续运行了，Go内建了一个Panic函数，它会产生一个运行时错误并重孩子程序。该函数接受一个任意类型的实参在程序终止时打印。</p>
<p>只需要在需要它的地方调用一下<code>panix()</code>就可以了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func init() &#123;</span><br><span class="line">	if user == &quot;&quot; &#123;</span><br><span class="line">		panic(&quot;user变量必须有值&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个示例，但是如果是设计库函数则应该避免使用panic，一个常见的使用panic的场景是初始化，如上面的示例。</p>
<h2 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h2><p>panic函数被调用后，程序将终止当前函数的执行。并开始追溯Go程的栈，运行任何被推迟的函数。我如果回溯到栈顶，程序会终止。<br>我们可以通过使用内建的recover函数来重新取回Go程的控制权。<br>调用recover将停止回溯，并返回传入panic的是西安。因为回溯只有被推迟执行的函数中的代码在执行，所以recover也只能在被推迟的函数中才有效。</p>
<p>一个应用：在服务器中终止失败的Go程而无需杀死其他正在执行的Go程：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">server</span><span class="params">(workChan &lt;-<span class="keyword">chan</span> *Work)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> work := <span class="keyword">range</span> workChan &#123;</span><br><span class="line">		<span class="keyword">go</span> safelyDo(work)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">safelyDo</span><span class="params">(work *Work)</span></span> &#123;</span><br><span class="line">	<span class="comment">// defer 函数是被推迟执行的</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Println(<span class="string">"work failed:"</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	do(work)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果do函数中调用panic函数，回溯会执行defer的函数，这时recover会起作用，打印错误信息后退出Go程。<br>可以使用上面的思路简化错误处理。</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/effective-go-note-3/" itemprop="url">
                  Effective Go笔记：空白标识符，接口检查与内嵌
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-07-20T12:34:50+08:00" content="2015-07-20">
              2015-07-20
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Programming/" itemprop="url" rel="index">
                    <span itemprop="name">Programming</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>effective go 中的部分笔记，这是第三部分 </p>
<p>部分笔记摘要,参考： <a href="https://go-zh.org/doc/effective_go.html" title="https://go-zh.org/doc/effective_go.html" target="_blank" rel="noopener">https://go-zh.org/doc/effective_go.html</a></p>
<h2 id="空白标识符"><a href="#空白标识符" class="headerlink" title="空白标识符"></a>空白标识符</h2><p>空白标识符是指”_”，是一个特殊的变量标识，在之前的for…range 循环中已经使用过。</p>
<h3 id="为未使用的变量或者包使用"><a href="#为未使用的变量或者包使用" class="headerlink" title="为未使用的变量或者包使用"></a>为未使用的变量或者包使用</h3><p>在Go中如果定义了一个变量没有使用，或者导入一个没有使用的包会在编译时报错，未使用的包会让程序体积变大并拖慢编译速度，初始化了而不是用的变量会留下某种隐患。<br>但是某些时候我们确实需要丢弃一些没有的变量，比如在for range循环中，可能需要丢弃键或者值，或者程序写到中途某些变量已经定义只是还没有使用等等，这时就需要空白标识符了。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 检查某个路径是否存在</span></span><br><span class="line"><span class="keyword">if</span> _, err := os.Stat(paht); os.IsNotExist(err) &#123;</span><br><span class="line">	fmt.Println(<span class="string">"path not exist"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于未使用的变量和未使用的导入包，可以把它们先赋值给空白标识符”_”关闭编译器的错误，在使用了这些变量后再删掉这些代码：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">fd = <span class="number">32</span></span><br><span class="line">....</span><br><span class="line">_ = fd</span><br><span class="line"><span class="keyword">var</span> _ = fmt.Printf  <span class="comment">// 用于调试使用，结束时删除</span></span><br></pre></td></tr></table></figure>
<h2 id="接口检查"><a href="#接口检查" class="headerlink" title="接口检查"></a>接口检查</h2><p>如果只需要判断某个类型是否实现了某个接口而不需要实际使用接口本身，可以使用空白标识符：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if _, ok := val.(Milk); ok &#123;</span><br><span class="line">	fmt.Printf(&quot;value %v has implement interface milk&quot;, val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 接口检查示例</span><br><span class="line">type iMilk interface &#123; </span><br><span class="line">  getName() string</span><br><span class="line">&#125;</span><br><span class="line">type Milk struct &#123; </span><br><span class="line">  name string</span><br><span class="line">&#125;</span><br><span class="line">func (m Milk) getName() string &#123;</span><br><span class="line">  return m.name</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">  var m interface &#123;&#125;</span><br><span class="line">  m = Milk&#123;&quot;yili&quot;&#125;</span><br><span class="line">  if _,ok := m.(iMilk); ok &#123;</span><br><span class="line">    fmt.Printf(&quot;value %v has implement iMilk\n &quot;, m)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    fmt.Println(&quot;has not implememt&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="内嵌-Embedding"><a href="#内嵌-Embedding" class="headerlink" title="内嵌/Embedding"></a>内嵌/Embedding</h2><p>Go语言并不提供典型的类与继承系统，所以也没有子类化的概念。继承是一个重要的概念，但是很多时候更推荐的做法是使用组合，Go提供的内嵌和组合概念差不多，可以将类型<strong>内嵌</strong>到结构体或者接口中，实现某种组合功能。</p>
<p>一种典型的内嵌的ReadWriter接口的定义：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">	Read(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">	Write(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 一个结合了Reader和Writer的接口</span></span><br><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">	Reader</span><br><span class="line">	Writer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以内嵌到一个结构体中</span></span><br><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">struct</span> &#123;</span><br><span class="line">	r *Reader</span><br><span class="line">	w *Writer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内嵌的接口一般需要实现被内嵌接口的方法，满足其需求，比如要提供Read方法：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(re *ReadWriter)</span> <span class="title">Read</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> rw.r.Read(p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而通过直接内嵌结构体，我们就能避免如此繁琐。 <strong>内嵌类型的方法可以直接引用</strong>。<br>当内嵌一个类型时，该类型的方法会成为外部类型的方法， 但当它们被调用时，该方法的接收者是内部类型，而非外部的。在我们的例子中，当 bufio.ReadWriter 的 Read 方法被调用时， 它与之前写的转发方法具有同样的效果；接收者是 ReadWriter 的 reader 字段，而非 ReadWriter 本身：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type Logger struct &#123;</span><br><span class="line">  content string</span><br><span class="line">&#125;</span><br><span class="line">func (l Logger) Log(s string) &#123;</span><br><span class="line">  l.content += s</span><br><span class="line">  fmt.Println(s)</span><br><span class="line">&#125;</span><br><span class="line">type infoLog struct &#123;</span><br><span class="line">  count int</span><br><span class="line">  *Logger</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">	var logger = infoLog&#123;0, &amp;Logger&#123;&quot;sss&quot;&#125; &#125;</span><br><span class="line">	// 可以直接调用内嵌类型的方法</span><br><span class="line">	logger.Log(&quot;embedding function invoke&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内嵌类型可能会引起命名冲突的问题。更深层次的命名字段或方法会被覆盖。若相同的嵌套层级上出现同名冲突，通常会产生一个错误。但是如果冲突的名字不会被使用就没有问题……</p>
<p><em>并发部分有点多，单独做一篇吧</em></p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/effective-go-note-4-concurrency/" itemprop="url">
                  Effective Go笔记：并发
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-07-20T12:34:50+08:00" content="2015-07-20">
              2015-07-20
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Programming/" itemprop="url" rel="index">
                    <span itemprop="name">Programming</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>effective go 中的部分笔记，这是第四部分 </p>
<p>部分笔记摘要,参考： <a href="https://go-zh.org/doc/effective_go.html" title="https://go-zh.org/doc/effective_go.html" target="_blank" rel="noopener">https://go-zh.org/doc/effective_go.html</a></p>
<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><h3 id="通过通信共享内存"><a href="#通过通信共享内存" class="headerlink" title="通过通信共享内存"></a>通过通信共享内存</h3><p>并发编程中很麻烦的一点是对共享变量访问的控制，在一般环境中，使用同步互斥锁机制等实现互斥的访问，使得代码繁琐而且难以理解。Go语言提出了一个独特的机制:信道。<br>Go将共享的值通过信道传递。在给定的时间点，只有一个Go程能访问信道中的值，在设计上杜绝了数据在同一时间点被放线程访问。</p>
<blockquote>
<p>不要通过共享内存来通信，而应通过通信来共享内存。</p>
</blockquote>
<p>为了方便理解，可以把Go的并发处理方式看做类型安全的Unix管道的实现。</p>
<h3 id="Go程-Goroutines"><a href="#Go程-Goroutines" class="headerlink" title="Go程/Goroutines"></a>Go程/Goroutines</h3><p>Go程是Golang提出的术语，Go程有简单的模型，它是与其他Go程并发运行在同一地址空间的<strong>函数</strong>。Go程可以看作是轻量级的线程，它的开销几乎只有栈空间的分配，它的使用很廉价。<br>Go程在多线程操作系统上可以实现多路复用，后面会详细讲到。多路复用在多线程编程中非常重要。</p>
<p>那如何运行一个Go程呢？很简单，只需要在要调用的函数前添加”go”关键字就能在Go程中运行这个函数，函数调用结束时，Go程也就自动退出。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> list.Sort()</span><br><span class="line"><span class="comment">// 使用函数字面量运行</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// do something here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="信道-Channels"><a href="#信道-Channels" class="headerlink" title="信道/Channels"></a>信道/Channels</h3><p>前面已经提到了信道的概念，在多线程中，具体怎么使用呢，下面就详细介绍<strong>信道（channel）</strong>。</p>
<p>之前讲过，在Go中切片，映射和信道都使用make来分配内存，make返回的值充当对底层数据结构的引用。信道的声明和初始化示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 前两个是无缓冲的正数类型信道</span><br><span class="line">c1 := make(chan int)</span><br><span class="line">c2 := make(chan int, 0)</span><br><span class="line">// 指向文件指针的带缓冲区的信道</span><br><span class="line">c3 := make(chan *os.File, 100)</span><br></pre></td></tr></table></figure>
<p>若不指定第二个参数，信道就是无缓冲的同步信道。使用一个同步信道，一个示例如下：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">c1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">// 一个不带缓冲的，同步信道</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  time.Sleep(<span class="number">500</span> * time.Millisecond)</span><br><span class="line">  <span class="comment">// send one value to channl</span></span><br><span class="line">  c1 &lt;- <span class="number">1</span></span><br><span class="line">&#125;()</span><br><span class="line"><span class="comment">// do something here</span></span><br><span class="line">fmt.Println(<span class="string">"wait for goroutine to quir"</span>)</span><br><span class="line">&lt;-c1 <span class="comment">// 主线程在此等待Go程结束,丢弃信道中的值，因为该值只是用作同步的标识</span></span><br><span class="line">fmt.Println(<span class="string">"go routine done"</span>)</span><br></pre></td></tr></table></figure>
<p>看完无缓冲的信道，下面看一下有缓冲的信道。有缓冲的信道可以看作是信号量，操作系统里面学过信号量的东西。信号量可以看作是资源不足时用来限制线程执行，使其等待的机制。常用来限制吞吐量，限制调用的process的数量等。<br>比如要对Web请求使用Go程处理：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func Serve(queue chan *Request) &#123;</span><br><span class="line">	for req := range queue &#123;</span><br><span class="line">		sem &lt;- 1</span><br><span class="line">		// 考虑到闭包的性质，这里传入值 *Request，</span><br><span class="line">		// 如果不使用 *Request则所有Go程处理的是同一个变量req</span><br><span class="line">		go func(req *Request) &#123;</span><br><span class="line">			process(req)</span><br><span class="line">			&lt;-sem</span><br><span class="line">		&#125;(req)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 另一种方式是，重新声明一个变量</span><br><span class="line">	for req := range queue &#123;</span><br><span class="line">		// 参考js中for循环中使用timeInterval函数时要重新声明变量</span><br><span class="line">		req := req // 为该Go程创建 req 的新实例。</span><br><span class="line">		sem &lt;- 1</span><br><span class="line">		go func() &#123;</span><br><span class="line">			process(req)</span><br><span class="line">			&lt;-sem</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="信道中的信道-channels-of-channels"><a href="#信道中的信道-channels-of-channels" class="headerlink" title="信道中的信道/channels of channels"></a>信道中的信道/channels of channels</h3><p><em>这部分比较麻烦，待续</em></p>
<h3 id="并行化-Parallelization"><a href="#并行化-Parallelization" class="headerlink" title="并行化/Parallelization"></a>并行化/Parallelization</h3><p>在多CPU核心上实现并行计算。</p>
<blockquote>
<p>并发是用可独立执行的组件构造程序的方法， 而并行则是为了效率在多CPU上平行地进行计算。Go仍然是种并发而非并行的语言，且Go的模型并不适合所有的并行问题</p>
</blockquote>
<p>目前Go运行时的实现默认并不会并行执行代码，它只为用户层代码提供单一的处理核心。 任意数量的Go程都可能在系统调用中被阻塞，而在任意时刻默认只有一个会执行用户层代码。 它应当变得更智能，而且它将来肯定会变得更智能。但现在，若你希望CPU并行执行， 就必须告诉运行时你希望同时有多少Go程能执行代码。有两种途径可以使用：</p>
<ol>
<li>在运行你的工作时将 GOMAXPROCS 环境变量设为你要使用的核心数</li>
<li>导入 runtime 包并调用 runtime.GOMAXPROCS(NCPU)。 runtime.NumCPU() 的值可能很有用，它会返回当前机器的逻辑CPU核心数。 </li>
</ol>
<p>当然，随着调度算法和运行时的改进，将来会不再需要这种方法。</p>
<h3 id="一个缓冲区泄漏示例-A-leak-buffer"><a href="#一个缓冲区泄漏示例-A-leak-buffer" class="headerlink" title="一个缓冲区泄漏示例/A leak buffer"></a>一个缓冲区泄漏示例/A leak buffer</h3><p>客户端Go程从某些来源，可能是网络中循环接收数据。为避免分配和释放缓冲区， 它保存了一个空闲链表，使用一个带缓冲信道表示。若信道为空，就会分配新的缓冲区。 一旦消息缓冲区就绪，它将通过 serverChan 被发送到服务器。 serverChan.</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> freeList = <span class="built_in">make</span>(<span class="keyword">chan</span> *Buffer, <span class="number">100</span>)</span><br><span class="line"><span class="keyword">var</span> serverChan = <span class="built_in">make</span>(<span class="keyword">chan</span> *Buffer)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">client</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">var</span> b *Buffer</span><br><span class="line">		<span class="comment">// 若缓冲区可用就用它，不可用就分配个新的。</span></span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> b = &lt;-freeList:</span><br><span class="line">			<span class="comment">// 获取一个，不做别的。</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="comment">// 非空闲，因此分配一个新的。</span></span><br><span class="line">			b = <span class="built_in">new</span>(Buffer)</span><br><span class="line">		&#125;</span><br><span class="line">		load(b)              <span class="comment">// 从网络中读取下一条消息。</span></span><br><span class="line">		serverChan &lt;- b   <span class="comment">// 发送至服务器。</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务器从客户端循环接收每个消息，处理它们，并将缓冲区返回给空闲列表。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">server</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		b := &lt;-serverChan    <span class="comment">// 等待工作。</span></span><br><span class="line">		process(b)</span><br><span class="line">		<span class="comment">// 若缓冲区有空间就重用它。</span></span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> freeList &lt;- b:</span><br><span class="line">			<span class="comment">// 将缓冲区放大空闲列表中，不做别的。</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="comment">// 空闲列表已满，保持就好。</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端试图从 freeList 中获取缓冲区；若没有缓冲区可用， 它就将分配一个新的。服务器将 b 放回空闲列表 freeList 中直到列表已满，此时缓冲区将被丢弃，并被垃圾回收器回收。（select 语句中的 default 子句在没有条件符合时执行，这也就意味着 selects 永远不会被阻塞。）依靠带缓冲的信道和垃圾回收器的记录， 我们仅用短短几行代码就构建了一个可能导致缓冲区槽位泄露的空闲列表。(没懂TT)</p>
<p>上一段的英文如下，总觉得中文的翻译不太对</p>
<p>The client attempts to retrieve a buffer from freeList; if none is available, it allocates a fresh one. The server’s send to freeList puts b back on the free list unless the list is full, in which case the buffer is dropped on the floor to be reclaimed by the garbage collector. (The default clauses in the select statements execute when no other case is ready, meaning that the selects never block.) This implementation builds a leaky bucket free list in just a few lines, relying on the buffered channel and the garbage collector for bookkeeping.</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/encasulating-a-memcache-client-for-php/" itemprop="url">
                  为PHP封装一个Memcache类
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-07-20T12:34:50+08:00" content="2015-07-20">
              2015-07-20
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Programming/" itemprop="url" rel="index">
                    <span itemprop="name">Programming</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>在php中经常会使用memcache或者memcached来做缓存系统，为了方便操作经常会对PHP提供的接口进行一层封装 </p>
<p>todo</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/go-efficient-string-concat/" itemprop="url">
                  Go 快速拼接字符串
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-07-20T12:34:50+08:00" content="2015-07-20">
              2015-07-20
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Programming/" itemprop="url" rel="index">
                    <span itemprop="name">Programming</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>对于频繁的字符串操作，可以使用bytes.Buffer接口提供的方法快速拼接 </p>
<p>和一般语言类似，Go也为string重载了”+”操作符，可以使用它进行字符串拼接，但是在C#和Java中对于大量的字符串拼接操作推荐使用StringBuilder这样的类，同样对于Go中的大量字符串拼接也不推荐直接使用”+”操作。</p>
<p>可以使用bytes.Buffer提供的方法进行快速拼接：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"bytes"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">concat</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> buffer bytes.Buffer</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++ &#123;</span><br><span class="line">		buffer.WriteString(<span class="string">"abcd"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	str := buffer.String()</span><br><span class="line">	<span class="comment">// do something to str</span></span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">return</span> str</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样可以获得O(n)的时间复杂度。</p>
<p>参考： <a href="http://stackoverflow.com/questions/1760757/" title="http://stackoverflow.com/questions/1760757/" target="_blank" rel="noopener">stackoverflow.com/</a></p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    

  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/16/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><span class="page-number current">17</span><a class="page-number" href="/page/18/">18</a><a class="extend next" rel="next" href="/page/18/"><i class="fa fa-angle-right"></i></a>
  </nav>



        </div>

        


        

      </div>

      
        
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="/images/avatar.jpg" alt="wuxu" itemprop="image"/>
          <p class="site-author-name" itemprop="name">wuxu</p>
        </div>
        <p class="site-description motion-element" itemprop="description">Wu Xu的个人博客</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">178</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">25</span>
              <span class="site-state-item-name">分类</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">148</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/wuxu92" target="_blank">
                  
                    <i class="fa fa-github"></i> GitHub
                  
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/wuxu92" target="_blank">
                  
                    <i class="fa fa-twitter"></i> Twitter
                  
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/kiwidock" target="_blank">
                  
                    <i class="fa fa-weibo"></i> Weibo
                  
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://douban.com/people/wuxu92" target="_blank">
                  
                    <i class="fa fa-douban"></i> Douban
                  
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.zhihu.com/people/wuxu92" target="_blank">
                  
                    <i class="fa fa-zhihu"></i> Zhihu
                  
                </a>
              </span>
            
          
        </div>

        
        
          <div class="cc-license motion-element" itemprop="license">
            <a href="http://creativecommons.org/licenses/by-nc-sa/4.0" class="cc-opacity" target="_blank">
              <img src="/images/cc-by-nc-sa.svg" alt="Creative Commons" />
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


      
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2014 - 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="icon-next-heart fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wuxu</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  

  
    
    

  


  

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.2"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.2"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
<script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

<script type="text/javascript" src="/js/motion.js?v=0.4.5.2" id="motion.global"></script>


  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  

  <script type="text/javascript" src="/js/bootstrap.js"></script>

  
  

  
  

</body>
</html>
