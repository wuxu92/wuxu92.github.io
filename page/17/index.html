<!doctype html>
<html class="theme-next ">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="google-site-verification" content="h7BaHlqi6VjlciSt0RF-KHgIXZcGfx3L3gyQ9qfx_ek" />










  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.4.5.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="wuxu, Golang, C, CPP, CS, PHP, " />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.2" />






<meta name="description" content="Wu Xu的个人博客">
<meta property="og:type" content="website">
<meta property="og:title" content="Wu Xu">
<meta property="og:url" content="http://blog.wuxu92.com/page/17/index.html">
<meta property="og:site_name" content="Wu Xu">
<meta property="og:description" content="Wu Xu的个人博客">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Wu Xu">
<meta name="twitter:description" content="Wu Xu的个人博客">



<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: '',
    sidebar: 'hide',
    motion: false
  };
</script>

  <title> Wu Xu </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-72131273-1', 'auto');
  ga('send', 'pageview');
</script>





  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>
    <div class="bottomband"></div> <!-- add by wuxu -->
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Wu Xu</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">关注C、Go、C++、JavaScript和UX</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th fa-fw"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-user fa-fw"></i> <br />
            
            关于
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content">
          
  <section id="posts" class="posts-expand">

    

    
    
      
      

      
    

    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/golang-errors/" itemprop="url">
                  Golang中的错误处理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-07-24T12:34:50+08:00" content="2015-07-24">
              2015-07-24
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/programming/" itemprop="url" rel="index">
                    <span itemprop="name">programming</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>Go语言提供了一套“新颖的”错误系统，与Java中的异常系统不一样，Go中没有抛出异常的概念</p>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>如果有一定面向对象语言编程经验的话，肯定会对异常/错误系统有一定的了解。如果使用Java比较多的话，一定会认为抛异常是编程语言天生的一部分，因为在Java中抛异常真的是太家常便饭，无处不在了；但是在Go语言中，根本没有异常这个东西！</p>
<p>看一段官方的QA是怎么解释这个问题的：</p>
<blockquote>
<p>We believe that coupling exceptions to a control structure, as in the try-catch-finally idiom,<strong> results in convoluted code</strong>. It also tends to encourage programmers to label too many ordinary errors, such as failing to open a file, as exceptional.</p>
<p>Go takes a different approach. For plain error handling, Go’s multi-value returns make it easy to report an error without overloading the return value. A canonical error type, coupled with Go’s other features, makes error handling pleasant but quite different from that in other languages.</p>
<p>Go also has a couple of built-in functions to signal and recover from truly exceptional conditions. The recovery mechanism is executed only as part of a function’s state being torn down after an error, which is sufficient to handle catastrophe but requires no extra control structures and, when used well, can result in clean error-handling code.</p>
</blockquote>
<p>多值返回为Go提供了一个新的错误处理机制，如果对为什么Go不提供异常体系感兴趣可以在 <a href="https://golang.org/doc/articles/defer_panic_recover.html" target="_blank" rel="noopener">这里</a> 找到更多的细节。</p>
<p>在之前文章中，已经使用过Go语言的多值返回来返回详细的错误描述。按照规定，<strong>错误的类型通常为error，这是一个内建的简单接口</strong>。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">	Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以通过实现这个接口定制错误，例如打开文件时的错误:</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> PathError <span class="keyword">struct</span> &#123;</span><br><span class="line">	Op <span class="keyword">string</span></span><br><span class="line">	Path <span class="keyword">string</span></span><br><span class="line">	Err error	<span class="comment">// 由系统调用返回</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fanc (pe *PathError) Error() <span class="keyword">string</span> &#123;</span><br><span class="line">	<span class="comment">// 返回定制的错误信息</span></span><br><span class="line">	<span class="keyword">return</span> pe.Op + <span class="string">" "</span> + pe.Path + <span class="string">": "</span> + pe.Err.Error()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>effective go中有一个示例非常有利于我们理解错误的使用,这段代码的作用是创建一个文件，如果创建失败，检查是不是磁盘空间不足，如果是则删除掉一些临时文件，再尝试创建一次：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for try:=0; try&lt;2; try++ &#123;</span><br><span class="line">	file, err := os.Create(filename)</span><br><span class="line">	if err == nill &#123;</span><br><span class="line">		return  //没有错误</span><br><span class="line">	&#125;</span><br><span class="line">	// 检查是不是空间不足</span><br><span class="line">	if e,ok := err.(*os.PathError); ok &amp;&amp; e.Err == syscall.ENOSPC &#123;</span><br><span class="line">		deleteTempFiles()  	// 删除一些临时文件</span><br><span class="line">		continue 			// 再创建一次</span><br><span class="line">	&#125;</span><br><span class="line">	return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以查看源码中PathError的实现 <a href="https://golang.org/src/os/error.go" title="https://golang.org/src/os/error.go" target="_blank" rel="noopener">https://golang.org/src/os/error.go</a></p>
<h2 id="Panic函数"><a href="#Panic函数" class="headerlink" title="Panic函数"></a>Panic函数</h2><p>函数可以通过将error作为额外的返回值来向调用者报告错误，对于一些“致命”的错误，他们导致程序不能继续运行了，Go内建了一个Panic函数，它会产生一个运行时错误并重孩子程序。该函数接受一个任意类型的实参在程序终止时打印。</p>
<p>只需要在需要它的地方调用一下<code>panix()</code>就可以了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func init() &#123;</span><br><span class="line">	if user == &quot;&quot; &#123;</span><br><span class="line">		panic(&quot;user变量必须有值&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个示例，但是如果是设计库函数则应该避免使用panic，一个常见的使用panic的场景是初始化，如上面的示例。</p>
<h2 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h2><p>panic函数被调用后，程序将终止当前函数的执行。并开始追溯Go程的栈，运行任何被推迟的函数。我如果回溯到栈顶，程序会终止。<br>我们可以通过使用内建的recover函数来重新取回Go程的控制权。<br>调用recover将停止回溯，并返回传入panic的是西安。因为回溯只有被推迟执行的函数中的代码在执行，所以recover也只能在被推迟的函数中才有效。</p>
<p>一个应用：在服务器中终止失败的Go程而无需杀死其他正在执行的Go程：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">server</span><span class="params">(workChan &lt;-<span class="keyword">chan</span> *Work)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> work := <span class="keyword">range</span> workChan &#123;</span><br><span class="line">		<span class="keyword">go</span> safelyDo(work)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">safelyDo</span><span class="params">(work *Work)</span></span> &#123;</span><br><span class="line">	<span class="comment">// defer 函数是被推迟执行的</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Println(<span class="string">"work failed:"</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	do(work)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果do函数中调用panic函数，回溯会执行defer的函数，这时recover会起作用，打印错误信息后退出Go程。<br>可以使用上面的思路简化错误处理。</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/effective-go-note-3/" itemprop="url">
                  Effective Go笔记：空白标识符，接口检查与内嵌
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-07-20T12:34:50+08:00" content="2015-07-20">
              2015-07-20
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/programming/" itemprop="url" rel="index">
                    <span itemprop="name">programming</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>effective go 中的部分笔记，这是第三部分 </p>
<p>部分笔记摘要,参考： <a href="https://go-zh.org/doc/effective_go.html" title="https://go-zh.org/doc/effective_go.html" target="_blank" rel="noopener">https://go-zh.org/doc/effective_go.html</a></p>
<h2 id="空白标识符"><a href="#空白标识符" class="headerlink" title="空白标识符"></a>空白标识符</h2><p>空白标识符是指”_”，是一个特殊的变量标识，在之前的for…range 循环中已经使用过。</p>
<h3 id="为未使用的变量或者包使用"><a href="#为未使用的变量或者包使用" class="headerlink" title="为未使用的变量或者包使用"></a>为未使用的变量或者包使用</h3><p>在Go中如果定义了一个变量没有使用，或者导入一个没有使用的包会在编译时报错，未使用的包会让程序体积变大并拖慢编译速度，初始化了而不是用的变量会留下某种隐患。<br>但是某些时候我们确实需要丢弃一些没有的变量，比如在for range循环中，可能需要丢弃键或者值，或者程序写到中途某些变量已经定义只是还没有使用等等，这时就需要空白标识符了。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 检查某个路径是否存在</span></span><br><span class="line"><span class="keyword">if</span> _, err := os.Stat(paht); os.IsNotExist(err) &#123;</span><br><span class="line">	fmt.Println(<span class="string">"path not exist"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于未使用的变量和未使用的导入包，可以把它们先赋值给空白标识符”_”关闭编译器的错误，在使用了这些变量后再删掉这些代码：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">fd = <span class="number">32</span></span><br><span class="line">....</span><br><span class="line">_ = fd</span><br><span class="line"><span class="keyword">var</span> _ = fmt.Printf  <span class="comment">// 用于调试使用，结束时删除</span></span><br></pre></td></tr></table></figure>
<h2 id="接口检查"><a href="#接口检查" class="headerlink" title="接口检查"></a>接口检查</h2><p>如果只需要判断某个类型是否实现了某个接口而不需要实际使用接口本身，可以使用空白标识符：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if _, ok := val.(Milk); ok &#123;</span><br><span class="line">	fmt.Printf(&quot;value %v has implement interface milk&quot;, val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 接口检查示例</span><br><span class="line">type iMilk interface &#123; </span><br><span class="line">  getName() string</span><br><span class="line">&#125;</span><br><span class="line">type Milk struct &#123; </span><br><span class="line">  name string</span><br><span class="line">&#125;</span><br><span class="line">func (m Milk) getName() string &#123;</span><br><span class="line">  return m.name</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">  var m interface &#123;&#125;</span><br><span class="line">  m = Milk&#123;&quot;yili&quot;&#125;</span><br><span class="line">  if _,ok := m.(iMilk); ok &#123;</span><br><span class="line">    fmt.Printf(&quot;value %v has implement iMilk\n &quot;, m)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    fmt.Println(&quot;has not implememt&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="内嵌-Embedding"><a href="#内嵌-Embedding" class="headerlink" title="内嵌/Embedding"></a>内嵌/Embedding</h2><p>Go语言并不提供典型的类与继承系统，所以也没有子类化的概念。继承是一个重要的概念，但是很多时候更推荐的做法是使用组合，Go提供的内嵌和组合概念差不多，可以将类型<strong>内嵌</strong>到结构体或者接口中，实现某种组合功能。</p>
<p>一种典型的内嵌的ReadWriter接口的定义：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">	Read(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">	Write(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 一个结合了Reader和Writer的接口</span></span><br><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">	Reader</span><br><span class="line">	Writer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以内嵌到一个结构体中</span></span><br><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">struct</span> &#123;</span><br><span class="line">	r *Reader</span><br><span class="line">	w *Writer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内嵌的接口一般需要实现被内嵌接口的方法，满足其需求，比如要提供Read方法：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(re *ReadWriter)</span> <span class="title">Read</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> rw.r.Read(p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而通过直接内嵌结构体，我们就能避免如此繁琐。 <strong>内嵌类型的方法可以直接引用</strong>。<br>当内嵌一个类型时，该类型的方法会成为外部类型的方法， 但当它们被调用时，该方法的接收者是内部类型，而非外部的。在我们的例子中，当 bufio.ReadWriter 的 Read 方法被调用时， 它与之前写的转发方法具有同样的效果；接收者是 ReadWriter 的 reader 字段，而非 ReadWriter 本身：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type Logger struct &#123;</span><br><span class="line">  content string</span><br><span class="line">&#125;</span><br><span class="line">func (l Logger) Log(s string) &#123;</span><br><span class="line">  l.content += s</span><br><span class="line">  fmt.Println(s)</span><br><span class="line">&#125;</span><br><span class="line">type infoLog struct &#123;</span><br><span class="line">  count int</span><br><span class="line">  *Logger</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">	var logger = infoLog&#123;0, &amp;Logger&#123;&quot;sss&quot;&#125; &#125;</span><br><span class="line">	// 可以直接调用内嵌类型的方法</span><br><span class="line">	logger.Log(&quot;embedding function invoke&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内嵌类型可能会引起命名冲突的问题。更深层次的命名字段或方法会被覆盖。若相同的嵌套层级上出现同名冲突，通常会产生一个错误。但是如果冲突的名字不会被使用就没有问题……</p>
<p><em>并发部分有点多，单独做一篇吧</em></p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/z-compile-vim-with-lua-support-in-centos-7/" itemprop="url">
                  CentOS 编译安装vim 7.4添加Lua支持
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-07-20T12:34:50+08:00" content="2015-07-20">
              2015-07-20
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/server/" itemprop="url" rel="index">
                    <span itemprop="name">server</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>一些vim插件需要提供Lua支持，特别是常见的补全插件，前段时间安装的[yadr](https</p>
<h2 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h2><p>首先，编译安装嘛，先下载源码， 可是呢这两sourceforge挂掉了，vim是托管在sf上的，导致下载页面也不能访问了，甚至vim的官网 <a href="http://www.vim.org" target="_blank" rel="noopener">www.vim.org</a> 也不能访问了，幸好vim在github上有一个备份  <a href="https://github.com/vim/vim" title="https://github.com/vim/vim" target="_blank" rel="noopener">https://github.com/vim/vim</a> 或者直接访问vim.org的ftp站： <a href="ftp://ftp.vim.org/pub/vim/unix/" title="ftp://ftp.vim.org/pub/vim/unix/" target="_blank" rel="noopener">ftp://ftp.vim.org/pub/vim/Unix/</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 使用下面之一的方法下载源码</span><br><span class="line">// git下载的话体积会大一些，好处是以后可以方便地更新</span><br><span class="line">git clone git@github.com:vim/vim.git</span><br><span class="line">wget -O ftp://ftp.vim.org/pub/vim/Unix/vim-7.4.tar.bz2</span><br><span class="line">wget ftp://ftp.vim.org/pub/vim/Unix/vim-7.4.tar.bz2</span><br><span class="line"></span><br><span class="line">tar xjvf vim-7.4.tar.bz2</span><br><span class="line">cd vim74</span><br></pre></td></tr></table></figure>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>vim的编译其实很简单，就configure-&gt;make-&gt;make install 这样的流程。但是要添加 Lua支持，就有一些麻烦了。</p>
<p>configure的配置大概是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./configure --prefix=/data/vim74 --with-features=huge --with-luajit --enable-luainterp=yes</span><br></pre></td></tr></table></figure>
<p>首先如果不在 configure配置那手动打开 <code>--enable-fail-if-missing</code> 这个选项，你会发现，configure没有问题，make没有问题，make install也OK，但是运行生成的vim： <code>vim --version</code>会发现Lua前面还是一个”-“（表示没有Lua支持）<br>因为其实configure那根本就没有找到lua的支持，只是默认跳过了 <code>--enable-luainterp=yes</code> 选项。。。<br>所以应该这样运行configure：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./configure --prefix=/data/vim74 --with-features=huge --with-luajit --enable-luainterp=yes --enable-fail-if-missing</span><br></pre></td></tr></table></figure>
<p>如果你的机器没有安装lua 和luajit的话会在检查lua支持那里中断了。</p>
<h3 id="安装Lua和LuaJit"><a href="#安装Lua和LuaJit" class="headerlink" title="安装Lua和LuaJit"></a>安装Lua和LuaJit</h3><p>Lua的安装倒是比较方便，官方repo里面就有，当然要想安装新版的也可以自己编译安装。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum install lua lua-devel -y</span><br></pre></td></tr></table></figure>
<p>luajit不在centos的官方repo里面，我们需要编译安装;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget http://luajit.org/download/LuaJIT-2.0.4.tar.gz</span><br><span class="line">tar -xzvf LuaJIT-2.0.4.tar.gz</span><br><span class="line">cd LuaJIT-2.0.4</span><br><span class="line">// 使用默认安装路径</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
<h2 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h2><p>安装好lua支持后，再运行configure就不会报错了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./configure --prefix=/data/vim74 --with-features=huge --with-luajit --enable-luainterp=yes --enable-fail-if-missing</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>运行编译的vim：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/data/vim74/bin/vim</span><br></pre></td></tr></table></figure>
<p>可能你会发现这样的错误:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/data/vim74/bin/vim: error while loading shared libraries: libluajit-5.1.so.2: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure>
<p>显然是安装的luajit有问题。我们找一下luajit这个.so文件在哪里</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo find / -name libluajit-5.1.so.2</span><br></pre></td></tr></table></figure>
<p>发现下面有这个文件：</p>
<ol>
<li>/home/wuxu/tars/ngx_openresty-1.7.10.2/build/luajit-root/data/openresty/luajit/lib/libluajit-5.1.so.2</li>
<li>/usr/local/lib/libluajit-5.1.so.2</li>
<li>/data/openresty/luajit/lib/libluajit-5.1.so.2</li>
</ol>
<p>显然1，3是openresty编译的，第二个才是我们安装luajit支持，我们需要给这个.so生成一个软链接，让vim能找到它：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo ln -s /usr/local/lib/libluajit-5.1.so.2 /lib64/libluajit-5.1.so.2</span><br></pre></td></tr></table></figure>
<p>这样再运行vim就不会有问题了～也有Lua支持了，不过Vim的自动补全还没用过呢，学会了再做记录吧。</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/encasulating-a-memcache-client-for-php/" itemprop="url">
                  为PHP封装一个Memcache类
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-07-20T12:34:50+08:00" content="2015-07-20">
              2015-07-20
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/programming/" itemprop="url" rel="index">
                    <span itemprop="name">programming</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>在php中经常会使用memcache或者memcached来做缓存系统，为了方便操作经常会对PHP提供的接口进行一层封装 </p>
<p>todo</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/go-efficient-string-concat/" itemprop="url">
                  Go 快速拼接字符串
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-07-20T12:34:50+08:00" content="2015-07-20">
              2015-07-20
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/programming/" itemprop="url" rel="index">
                    <span itemprop="name">programming</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>对于频繁的字符串操作，可以使用bytes.Buffer接口提供的方法快速拼接 </p>
<p>和一般语言类似，Go也为string重载了”+”操作符，可以使用它进行字符串拼接，但是在C#和Java中对于大量的字符串拼接操作推荐使用StringBuilder这样的类，同样对于Go中的大量字符串拼接也不推荐直接使用”+”操作。</p>
<p>可以使用bytes.Buffer提供的方法进行快速拼接：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"bytes"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">concat</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> buffer bytes.Buffer</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++ &#123;</span><br><span class="line">		buffer.WriteString(<span class="string">"abcd"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	str := buffer.String()</span><br><span class="line">	<span class="comment">// do something to str</span></span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">return</span> str</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样可以获得O(n)的时间复杂度。</p>
<p>参考： <a href="http://stackoverflow.com/questions/1760757/" title="http://stackoverflow.com/questions/1760757/" target="_blank" rel="noopener">stackoverflow.com/</a></p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/effective-go-note-4-concurrency/" itemprop="url">
                  Effective Go笔记：并发
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-07-20T12:34:50+08:00" content="2015-07-20">
              2015-07-20
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/programming/" itemprop="url" rel="index">
                    <span itemprop="name">programming</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>effective go 中的部分笔记，这是第四部分 </p>
<p>部分笔记摘要,参考： <a href="https://go-zh.org/doc/effective_go.html" title="https://go-zh.org/doc/effective_go.html" target="_blank" rel="noopener">https://go-zh.org/doc/effective_go.html</a></p>
<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><h3 id="通过通信共享内存"><a href="#通过通信共享内存" class="headerlink" title="通过通信共享内存"></a>通过通信共享内存</h3><p>并发编程中很麻烦的一点是对共享变量访问的控制，在一般环境中，使用同步互斥锁机制等实现互斥的访问，使得代码繁琐而且难以理解。Go语言提出了一个独特的机制:信道。<br>Go将共享的值通过信道传递。在给定的时间点，只有一个Go程能访问信道中的值，在设计上杜绝了数据在同一时间点被放线程访问。</p>
<blockquote>
<p>不要通过共享内存来通信，而应通过通信来共享内存。</p>
</blockquote>
<p>为了方便理解，可以把Go的并发处理方式看做类型安全的Unix管道的实现。</p>
<h3 id="Go程-Goroutines"><a href="#Go程-Goroutines" class="headerlink" title="Go程/Goroutines"></a>Go程/Goroutines</h3><p>Go程是Golang提出的术语，Go程有简单的模型，它是与其他Go程并发运行在同一地址空间的<strong>函数</strong>。Go程可以看作是轻量级的线程，它的开销几乎只有栈空间的分配，它的使用很廉价。<br>Go程在多线程操作系统上可以实现多路复用，后面会详细讲到。多路复用在多线程编程中非常重要。</p>
<p>那如何运行一个Go程呢？很简单，只需要在要调用的函数前添加”go”关键字就能在Go程中运行这个函数，函数调用结束时，Go程也就自动退出。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> list.Sort()</span><br><span class="line"><span class="comment">// 使用函数字面量运行</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// do something here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="信道-Channels"><a href="#信道-Channels" class="headerlink" title="信道/Channels"></a>信道/Channels</h3><p>前面已经提到了信道的概念，在多线程中，具体怎么使用呢，下面就详细介绍<strong>信道（channel）</strong>。</p>
<p>之前讲过，在Go中切片，映射和信道都使用make来分配内存，make返回的值充当对底层数据结构的引用。信道的声明和初始化示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 前两个是无缓冲的正数类型信道</span><br><span class="line">c1 := make(chan int)</span><br><span class="line">c2 := make(chan int, 0)</span><br><span class="line">// 指向文件指针的带缓冲区的信道</span><br><span class="line">c3 := make(chan *os.File, 100)</span><br></pre></td></tr></table></figure>
<p>若不指定第二个参数，信道就是无缓冲的同步信道。使用一个同步信道，一个示例如下：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">c1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">// 一个不带缓冲的，同步信道</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  time.Sleep(<span class="number">500</span> * time.Millisecond)</span><br><span class="line">  <span class="comment">// send one value to channl</span></span><br><span class="line">  c1 &lt;- <span class="number">1</span></span><br><span class="line">&#125;()</span><br><span class="line"><span class="comment">// do something here</span></span><br><span class="line">fmt.Println(<span class="string">"wait for goroutine to quir"</span>)</span><br><span class="line">&lt;-c1 <span class="comment">// 主线程在此等待Go程结束,丢弃信道中的值，因为该值只是用作同步的标识</span></span><br><span class="line">fmt.Println(<span class="string">"go routine done"</span>)</span><br></pre></td></tr></table></figure>
<p>看完无缓冲的信道，下面看一下有缓冲的信道。有缓冲的信道可以看作是信号量，操作系统里面学过信号量的东西。信号量可以看作是资源不足时用来限制线程执行，使其等待的机制。常用来限制吞吐量，限制调用的process的数量等。<br>比如要对Web请求使用Go程处理：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func Serve(queue chan *Request) &#123;</span><br><span class="line">	for req := range queue &#123;</span><br><span class="line">		sem &lt;- 1</span><br><span class="line">		// 考虑到闭包的性质，这里传入值 *Request，</span><br><span class="line">		// 如果不使用 *Request则所有Go程处理的是同一个变量req</span><br><span class="line">		go func(req *Request) &#123;</span><br><span class="line">			process(req)</span><br><span class="line">			&lt;-sem</span><br><span class="line">		&#125;(req)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 另一种方式是，重新声明一个变量</span><br><span class="line">	for req := range queue &#123;</span><br><span class="line">		// 参考js中for循环中使用timeInterval函数时要重新声明变量</span><br><span class="line">		req := req // 为该Go程创建 req 的新实例。</span><br><span class="line">		sem &lt;- 1</span><br><span class="line">		go func() &#123;</span><br><span class="line">			process(req)</span><br><span class="line">			&lt;-sem</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="信道中的信道-channels-of-channels"><a href="#信道中的信道-channels-of-channels" class="headerlink" title="信道中的信道/channels of channels"></a>信道中的信道/channels of channels</h3><p><em>这部分比较麻烦，待续</em></p>
<h3 id="并行化-Parallelization"><a href="#并行化-Parallelization" class="headerlink" title="并行化/Parallelization"></a>并行化/Parallelization</h3><p>在多CPU核心上实现并行计算。</p>
<blockquote>
<p>并发是用可独立执行的组件构造程序的方法， 而并行则是为了效率在多CPU上平行地进行计算。Go仍然是种并发而非并行的语言，且Go的模型并不适合所有的并行问题</p>
</blockquote>
<p>目前Go运行时的实现默认并不会并行执行代码，它只为用户层代码提供单一的处理核心。 任意数量的Go程都可能在系统调用中被阻塞，而在任意时刻默认只有一个会执行用户层代码。 它应当变得更智能，而且它将来肯定会变得更智能。但现在，若你希望CPU并行执行， 就必须告诉运行时你希望同时有多少Go程能执行代码。有两种途径可以使用：</p>
<ol>
<li>在运行你的工作时将 GOMAXPROCS 环境变量设为你要使用的核心数</li>
<li>导入 runtime 包并调用 runtime.GOMAXPROCS(NCPU)。 runtime.NumCPU() 的值可能很有用，它会返回当前机器的逻辑CPU核心数。 </li>
</ol>
<p>当然，随着调度算法和运行时的改进，将来会不再需要这种方法。</p>
<h3 id="一个缓冲区泄漏示例-A-leak-buffer"><a href="#一个缓冲区泄漏示例-A-leak-buffer" class="headerlink" title="一个缓冲区泄漏示例/A leak buffer"></a>一个缓冲区泄漏示例/A leak buffer</h3><p>客户端Go程从某些来源，可能是网络中循环接收数据。为避免分配和释放缓冲区， 它保存了一个空闲链表，使用一个带缓冲信道表示。若信道为空，就会分配新的缓冲区。 一旦消息缓冲区就绪，它将通过 serverChan 被发送到服务器。 serverChan.</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> freeList = <span class="built_in">make</span>(<span class="keyword">chan</span> *Buffer, <span class="number">100</span>)</span><br><span class="line"><span class="keyword">var</span> serverChan = <span class="built_in">make</span>(<span class="keyword">chan</span> *Buffer)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">client</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">var</span> b *Buffer</span><br><span class="line">		<span class="comment">// 若缓冲区可用就用它，不可用就分配个新的。</span></span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> b = &lt;-freeList:</span><br><span class="line">			<span class="comment">// 获取一个，不做别的。</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="comment">// 非空闲，因此分配一个新的。</span></span><br><span class="line">			b = <span class="built_in">new</span>(Buffer)</span><br><span class="line">		&#125;</span><br><span class="line">		load(b)              <span class="comment">// 从网络中读取下一条消息。</span></span><br><span class="line">		serverChan &lt;- b   <span class="comment">// 发送至服务器。</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务器从客户端循环接收每个消息，处理它们，并将缓冲区返回给空闲列表。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">server</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		b := &lt;-serverChan    <span class="comment">// 等待工作。</span></span><br><span class="line">		process(b)</span><br><span class="line">		<span class="comment">// 若缓冲区有空间就重用它。</span></span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> freeList &lt;- b:</span><br><span class="line">			<span class="comment">// 将缓冲区放大空闲列表中，不做别的。</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="comment">// 空闲列表已满，保持就好。</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端试图从 freeList 中获取缓冲区；若没有缓冲区可用， 它就将分配一个新的。服务器将 b 放回空闲列表 freeList 中直到列表已满，此时缓冲区将被丢弃，并被垃圾回收器回收。（select 语句中的 default 子句在没有条件符合时执行，这也就意味着 selects 永远不会被阻塞。）依靠带缓冲的信道和垃圾回收器的记录， 我们仅用短短几行代码就构建了一个可能导致缓冲区槽位泄露的空闲列表。(没懂TT)</p>
<p>上一段的英文如下，总觉得中文的翻译不太对</p>
<p>The client attempts to retrieve a buffer from freeList; if none is available, it allocates a fresh one. The server’s send to freeList puts b back on the free list unless the list is full, in which case the buffer is dropped on the floor to be reclaimed by the garbage collector. (The default clauses in the select statements execute when no other case is ready, meaning that the selects never block.) This implementation builds a leaky bucket free list in just a few lines, relying on the buffered channel and the garbage collector for bookkeeping.</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/compile-and-install-php7-beta1/" itemprop="url">
                  编译安装PHP7 beta1
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-07-19T12:34:50+08:00" content="2015-07-19">
              2015-07-19
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/server/" itemprop="url" rel="index">
                    <span itemprop="name">server</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <p>前段时间去php.net上闲逛发现PHP7的beta1版本出来了，就尝试着编译安装了一下</p>
<p>之前在鸟哥的博客里看到了他们做的PHP的性能测试，相对于PHP5.6都是有很大的提升的，并且PHP的主版本号已经是2004年发布PHP5后，11年来首次更新，肯定PHP７是有很大的改变的，下面那就来试试PHP7的beta版吧，正式版大概在今年年底会发布。</p>
<h2 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h2><p>测试版本的PHP下载页面： <a href="https://downloads.php.net/~ab/" title="https://downloads.php.net/~ab/" target="_blank" rel="noopener">https://downloads.php.net/~ab/</a></p>
<p>php7 beta1: <a href="https://downloads.php.net/~ab/php-7.0.0beta1.tar.gz" title="https://downloads.php.net/~ab/php-7.0.0beta1.tar.gz" target="_blank" rel="noopener">https://downloads.php.net/~ab/php-7.0.0beta1.tar.gz</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https://downloads.php.net/~ab/php-7.0.0beta1.tar.gz</span><br><span class="line">或者</span><br><span class="line">curl -O https://downloads.php.net/~ab/php-7.0.0beta1.tar.gz</span><br></pre></td></tr></table></figure>
          <div class="post-more-link text-center">
            <a class="btn" href="/compile-and-install-php7-beta1/" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/vim-shortcuts/" itemprop="url">
                  vim 常用的快捷键
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-07-19T12:34:50+08:00" content="2015-07-19">
              2015-07-19
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>vim作为键盘操作为主的编辑器，有许多功能丰富的快捷键，其实不只在普通模式下有快捷键，其实在插入模式下也有一些有用的快捷键…</p>
<h2 id="插入模式的快捷键"><a href="#插入模式的快捷键" class="headerlink" title="插入模式的快捷键"></a>插入模式的快捷键</h2><p>对于新手来说，vim的插入模式和记事本一样“好用”，记事本有一些快捷键，但是在vim的插入模式下，我们却经常忘记使用快捷键：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;C-h&gt;/Ctrl+h	 删除前一个字符</span><br><span class="line">&lt;C-w&gt;			删除前一个单词</span><br><span class="line">&lt;C-u&gt;			删除到行首</span><br><span class="line"></span><br><span class="line">Esc/&lt;C-[&gt;	Esc进入普通模式，其实Ctrl+[和Esc的作用是一样的</span><br><span class="line">&lt;Ctrl-o&gt;		Ctrl+o进入插入-普通模式，此模式下可以执行一个普通模式下的命令并返回插入模式，</span><br><span class="line">			常用 &lt;C-o&gt;zz：保持插入模式并把光标行滚动到屏幕中间</span><br></pre></td></tr></table></figure>
<p>可以在插入模式下使用vim的计算工具<code>&lt;C-r&gt;=</code> 插入模式下这个组合键访问表达式寄存器(=)，这是会在屏幕下方提示输入运算符，输入<code>1+2+3</code> 后 <code>&lt;CR&gt;</code>（回车），vim就会把运算结果插入到刚刚的光标位置，并且仍然是插入模式</p>
<p>对于104键的键盘可以在插入模式下使用<code>Shift+insert</code>组合键粘贴系统剪切板的内容，可以使用<code>&lt;C-r&gt;n</code>粘贴寄存器n中的内容</p>
<p>在插入模式下 <code>&lt;C-v&gt;</code>用来插入一个特殊字符，比如<code>&lt;C-v&gt;u00bf</code>可以插入一个返过来的问号~这是用来插入unicode字符的。</p>
<h2 id="可视模式下的快捷键"><a href="#可视模式下的快捷键" class="headerlink" title="可视模式下的快捷键"></a>可视模式下的快捷键</h2><h2 id="普通模式下的快捷键"><a href="#普通模式下的快捷键" class="headerlink" title="普通模式下的快捷键"></a>普通模式下的快捷键</h2><h2 id="分栏"><a href="#分栏" class="headerlink" title="分栏"></a>分栏</h2><p><code>sp {filename}</code> 水平切分上下两栏。filename可选，默认当前文件，快捷键<code>&lt;C-w&gt;s</code><br><code>vsp {filenamem}</code> 垂直切分，左右两栏 <code>&lt;C-w&gt;v</code></p>
<p>如果安装了yadr扩展的话可以使用<code>contrl+h,j,k,l</code>来跳转到相应方向的分栏<br>没有yadr可以使用快捷键 <code>&lt;C-w&gt;&lt;C-w&gt;</code>在分栏中循环切换，或这使用<code>&lt;C-w&gt;[h,j,k,l]</code> 跳转到分栏。</p>
<p><code>&lt;C-w&gt;=</code> 所有窗口等宽等高<br><code>&lt;C-w&gt;_</code> 最大化活动窗口高度<br><code>&lt;C-w&gt;|</code> 最大化活动窗口宽度<br><code>[n]&lt;C-w&gt;_</code> 活动窗口高度设为n<br><code>[n]&lt;C-w&gt;|</code> 活动窗口宽度设为n</p>
<p><code>:clo</code> 关闭活动窗口， 快捷键 <code>&lt;C-w&gt;c</code><br><code>:on[ly]</code> 只保留当前窗口   快捷键 <code>&lt;C-w&gt;o</code></p>
<p>很有用的重新对其代码,命令模式下 <code>gg=G</code><br><em>待续</em></p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/effective-go-note-2/" itemprop="url">
                  Effective Go笔记：方法，接口与其他类型
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-07-19T12:34:50+08:00" content="2015-07-19">
              2015-07-19
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/programming/" itemprop="url" rel="index">
                    <span itemprop="name">programming</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>effective go 中的部分笔记，这是第二部分 </p>
<p>部分笔记摘要,参考： <a href="https://go-zh.org/doc/effective_go.html" title="https://go-zh.org/doc/effective_go.html" target="_blank" rel="noopener">https://go-zh.org/doc/effective_go.html</a></p>
<h2 id="方法-Methods"><a href="#方法-Methods" class="headerlink" title="方法/Methods"></a>方法/Methods</h2><p>与一般的面向对象语言不同；一般的面向对象语言定义类，然后在类中定义属性和方法，通过类的继承来抽象一套机制，但是在Go中，首先是定义结构，然后为已经命名的结构（除了指针或接口）定义方法，这里有一个方法接收者的概念，为一个结构体绑定方法的常用用法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type Book struct &#123;</span><br><span class="line">	price float64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (p Book) Disount(c float64) float64 &#123;</span><br><span class="line">	// 注意int和float64类型不一样，</span><br><span class="line">	// 在Go中并不能直接操作，需要进行类型转换</span><br><span class="line">	// 但是float64 可以与字面量值直接相乘... p.price*100不会有问题</span><br><span class="line">	return p.price * c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对一些方法，传入的参数是值的拷贝而不是地址，经常需要在方法的结尾放回新的结果，可以通过把参数的指针传入，直接修改参数的地址指向的值，常见的io.Write接口就是在指针添加方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type byteSlice []byte</span><br><span class="line">func (slice *byteSlice) Write(data []byte) (n int, err error) &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var b byteSlice</span><br><span class="line">fmt.Fprintf(&amp;b, &quot;this is a string&quot;, 7)</span><br></pre></td></tr></table></figure>
<p><strong>以指针或值为接收者的区别在于：值方法可通过指针和值调用， 而指针方法只能通过指针来调用</strong></p>
<h2 id="接口与其他类型-interface"><a href="#接口与其他类型-interface" class="headerlink" title="接口与其他类型/interface"></a>接口与其他类型/interface</h2><p>Go中的接口为指定对象的行为提供了一种方法：<strong>如果某样东西可以完成这个， 那么它就可以用在这里。</strong>我们已经见过许多简单的示例了；通过实现 String 方法，我们可以自定义打印函数，而通过 Write 方法，Fprintf 则能对任何对象产生输出。</p>
<p>Go中的的接口只是需要实现它的类接受了同名的方法即可，这是很特别的。</p>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type squence []int</span><br><span class="line">func (s squence) String stirng &#123;</span><br><span class="line">	// do some thing to s</span><br><span class="line">	return ftm.Sprint(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果忽略类型名，squence和[]int其实是相同的，只不过squence有一个新的类型名而已，所以在他们之间进行类型转换是可以的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">is := []int(s)</span><br></pre></td></tr></table></figure>
<p>在Go语言中，为了访问不同的方法集会经常进行类型转换。甚至对int和float之间的简单运算都会用到类型转换。</p>
<h3 id="接口转换与类型断言"><a href="#接口转换与类型断言" class="headerlink" title="接口转换与类型断言"></a>接口转换与类型断言</h3><p>对于混合类型，我们经常需要将一种接口转换为另一种接口，要判断一个值是否实现了某个接口，需要使用到<strong>类型断言</strong>。类型断言接受一个接口值，并从中提取指定的明确的明确类型的值。与其他语言判断类型不同，它的用法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var.(typeName)</span><br><span class="line">str.(string)</span><br><span class="line"></span><br><span class="line">// 对于使用接口定义的值，可以使用下面的方式</span><br><span class="line">// 其中iv是用 var iv interface&#123;&#125; 定义的，Milk是一中类型</span><br><span class="line">switch str := iv.(type) &#123;</span><br><span class="line">case string:</span><br><span class="line">  fmt.Println(str)</span><br><span class="line">case Milk:</span><br><span class="line">  fmt.Println(&quot;milk&quot;, str)</span><br><span class="line">default:</span><br><span class="line">  fmt.Println(&quot;interface type:&quot;, str)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个看起来很奇怪的用法，不知道Go中有没有提供想instanceof这样的关键字。</p>
<h3 id="通用性-Generality"><a href="#通用性-Generality" class="headerlink" title="通用性/Generality"></a>通用性/Generality</h3><blockquote>
<p>这部分还不是很了解</p>
</blockquote>
<p>若某种现有的类型仅实现了一个接口，且除此之外并无可导出的方法，则该类型本身就无需导出。 仅导出该接口能让我们更专注于其行为而非实现，其它属性不同的实现则能镜像该原始类型的行为。 这也能够避免为每个通用接口的实例重复编写文档。</p>
<p>在这种情况下，构造函数应当返回一个接口值而非实现的类型。</p>
<h2 id="接口和方法"><a href="#接口和方法" class="headerlink" title="接口和方法"></a>接口和方法</h2><p>Go中几乎任何类型(<strong>除了指针和接口</strong>)都能添加方法（添加的示例已经看过很多了，就不赘述了），因此几乎任何类型都能满足一个接口（即使是基于int的类型也能用来满足一个特别的接口），常见的用法就是<strong>任何实现了ServeHTTP方法的对象都能处理HTTP请求</strong>。</p>
<blockquote>
<p>甚至可以为func添加方法，当然需要先将函数定义为一种新类型</p>
</blockquote>
<p>Handler接口定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type Handler interface &#123;</span><br><span class="line">	ServeHTTP(ResponseWriter, *Request)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是一个实现该接口的示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &quot;net/http&quot;</span><br><span class="line"></span><br><span class="line">type milkServer struct &#123;</span><br><span class="line">	n int</span><br><span class="line">&#125;</span><br><span class="line">// 注意参数中的http不能少，参考Go的包机制</span><br><span class="line">func (m *MilkServer) ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line">	m.n++</span><br><span class="line">	// do some thing</span><br><span class="line">	fmt.Fprintf(w, &quot;request count at %d\n&quot;, m.n)</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 添加绑定</span><br><span class="line">m := new(Milk)</span><br><span class="line">http.Handle(&quot;/count&quot;, m)</span><br><span class="line">// 也可以直接绑定一个与ServeHTTP签名相同的函数</span><br><span class="line">func ArgsFunc(w http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line">http.HandleFunc(&quot;args&quot;, ArgsFunc)</span><br></pre></td></tr></table></figure>
<p>当然也可以绑定到一个信道上面，然后使用信道新更新一些内部状态：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type Chan chan *http.Request</span><br><span class="line">func (c Chan) ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line">	c &lt;- req</span><br><span class="line">	fmt.Fprint(w, &quot;request received&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/go-iota-spc/" itemprop="url">
                  Golang 中iota的用法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-07-18T12:34:50+08:00" content="2015-07-18">
              2015-07-18
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/programming/" itemprop="url" rel="index">
                    <span itemprop="name">programming</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>Golang中可以使用iota方便的定义复杂的常量结构，下面是golang spec中的说明</p>
<p>Within a constant declaration, the predeclared identifier iota represents successive untyped integer constants. It is reset to 0 whenever the reserved word const appears in the source and increments after each ConstSpec. It can be used to construct a set of related constants:</p>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const (  // iota is reset to 0</span><br><span class="line">	c0 = iota  // c0 == 0</span><br><span class="line">	c1 = iota  // c1 == 1</span><br><span class="line">	c2 = iota  // c2 == 2</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">	a = 1 &lt;&lt; iota  // a == 1 (iota has been reset)</span><br><span class="line">	b = 1 &lt;&lt; iota  // b == 2</span><br><span class="line">	c = 1 &lt;&lt; iota  // c == 4</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">	u         = iota * 42  // u == 0     (untyped integer constant)</span><br><span class="line">	v float64 = iota * 42  // v == 42.0  (float64 constant)</span><br><span class="line">	w         = iota * 42  // w == 84    (untyped integer constant)</span><br><span class="line">)</span><br><span class="line">``</span><br><span class="line">const x = iota  // x == 0 (iota has been reset)</span><br><span class="line">const y = iota  // y == 0 (iota has been reset)</span><br></pre></td></tr></table></figure>
<p>Within an ExpressionList, the value of each iota is the same because it is only incremented after each ConstSpec:</p>
<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const (</span><br><span class="line">	bit0, mask0 = 1 &lt;&lt; iota, 1&lt;&lt;iota - 1  // bit0 == 1, mask0 == 0</span><br><span class="line">	bit1, mask1                           // bit1 == 2, mask1 == 1</span><br><span class="line">	_, _                                  // skips iota == 2</span><br><span class="line">	bit3, mask3                           // bit3 == 8, mask3 == 7</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>This last example exploits the implicit repetition of the last non-empty expression list.</p>
<p>iota是一个比较有特色的东西，看完这两个例子基本就知道怎么用了，相当于它是一个从0开始自动增加的变量，可以重复使用，可以用来定义单位的大小，比如KB，MB，GB等</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    

  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/16/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><span class="page-number current">17</span><a class="page-number" href="/page/18/">18</a><a class="extend next" rel="next" href="/page/18/"><i class="fa fa-angle-right"></i></a>
  </nav>



        </div>

        


        

      </div>

      
        
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="/images/avatar.jpg" alt="wuxu" itemprop="image"/>
          <p class="site-author-name" itemprop="name">wuxu</p>
        </div>
        <p class="site-description motion-element" itemprop="description">Wu Xu的个人博客</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">173</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">24</span>
              <span class="site-state-item-name">分类</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">145</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/wuxu92" target="_blank">
                  
                    <i class="fa fa-github"></i> GitHub
                  
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/wuxu92" target="_blank">
                  
                    <i class="fa fa-twitter"></i> Twitter
                  
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/kiwidock" target="_blank">
                  
                    <i class="fa fa-weibo"></i> Weibo
                  
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://douban.com/people/wuxu92" target="_blank">
                  
                    <i class="fa fa-douban"></i> Douban
                  
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.zhihu.com/people/wuxu92" target="_blank">
                  
                    <i class="fa fa-zhihu"></i> Zhihu
                  
                </a>
              </span>
            
          
        </div>

        
        
          <div class="cc-license motion-element" itemprop="license">
            <a href="http://creativecommons.org/licenses/by-nc-sa/4.0" class="cc-opacity" target="_blank">
              <img src="/images/cc-by-nc-sa.svg" alt="Creative Commons" />
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


      
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2014 - 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="icon-next-heart fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wuxu</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  

  
    
    

  


  

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.2"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.2"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
<script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

<script type="text/javascript" src="/js/motion.js?v=0.4.5.2" id="motion.global"></script>


  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  

  <script type="text/javascript" src="/js/bootstrap.js"></script>

  
  

  
  

</body>
</html>
