<!doctype html>
<html class="theme-next ">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="google-site-verification" content="h7BaHlqi6VjlciSt0RF-KHgIXZcGfx3L3gyQ9qfx_ek" />










  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.4.5.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="wuxu, Golang, C, CPP, CS, PHP, " />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.2" />






<meta name="description" content="Wu Xu的个人博客">
<meta property="og:type" content="website">
<meta property="og:title" content="Wu Xu">
<meta property="og:url" content="http://blog.wuxu92.com/page/17/index.html">
<meta property="og:site_name" content="Wu Xu">
<meta property="og:description" content="Wu Xu的个人博客">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Wu Xu">
<meta name="twitter:description" content="Wu Xu的个人博客">



<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: '',
    sidebar: 'hide',
    motion: false
  };
</script>

  <title> Wu Xu </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-72131273-1', 'auto');
  ga('send', 'pageview');
</script>





  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>
    <div class="bottomband"></div> <!-- add by wuxu -->
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Wu Xu</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">关注C、Go、C++、JavaScript和UX</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th fa-fw"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-user fa-fw"></i> <br />
            
            关于
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content">
          
  <section id="posts" class="posts-expand">

    

    
    
      
      

      
    

    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/go-efficient-string-concat/" itemprop="url">
                  Go 快速拼接字符串
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-07-20T12:34:50+08:00" content="2015-07-20">
              2015-07-20
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/programming/" itemprop="url" rel="index">
                    <span itemprop="name">programming</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>对于频繁的字符串操作，可以使用bytes.Buffer接口提供的方法快速拼接 </p>
<p>和一般语言类似，Go也为string重载了”+”操作符，可以使用它进行字符串拼接，但是在C#和Java中对于大量的字符串拼接操作推荐使用StringBuilder这样的类，同样对于Go中的大量字符串拼接也不推荐直接使用”+”操作。</p>
<p>可以使用bytes.Buffer提供的方法进行快速拼接：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"bytes"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">concat</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> buffer bytes.Buffer</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++ &#123;</span><br><span class="line">		buffer.WriteString(<span class="string">"abcd"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	str := buffer.String()</span><br><span class="line">	<span class="comment">// do something to str</span></span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">return</span> str</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样可以获得O(n)的时间复杂度。</p>
<p>参考： <a href="http://stackoverflow.com/questions/1760757/" title="http://stackoverflow.com/questions/1760757/" target="_blank" rel="noopener">stackoverflow.com/</a></p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/z-compile-vim-with-lua-support-in-centos-7/" itemprop="url">
                  CentOS 编译安装vim 7.4添加Lua支持
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-07-20T12:34:50+08:00" content="2015-07-20">
              2015-07-20
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/server/" itemprop="url" rel="index">
                    <span itemprop="name">server</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>一些vim插件需要提供Lua支持，特别是常见的补全插件，前段时间安装的[yadr](https</p>
<h2 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h2><p>首先，编译安装嘛，先下载源码， 可是呢这两sourceforge挂掉了，vim是托管在sf上的，导致下载页面也不能访问了，甚至vim的官网 <a href="http://www.vim.org" target="_blank" rel="noopener">www.vim.org</a> 也不能访问了，幸好vim在github上有一个备份  <a href="https://github.com/vim/vim" title="https://github.com/vim/vim" target="_blank" rel="noopener">https://github.com/vim/vim</a> 或者直接访问vim.org的ftp站： <a href="ftp://ftp.vim.org/pub/vim/unix/" title="ftp://ftp.vim.org/pub/vim/unix/" target="_blank" rel="noopener">ftp://ftp.vim.org/pub/vim/Unix/</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 使用下面之一的方法下载源码</span><br><span class="line">// git下载的话体积会大一些，好处是以后可以方便地更新</span><br><span class="line">git clone git@github.com:vim/vim.git</span><br><span class="line">wget -O ftp://ftp.vim.org/pub/vim/Unix/vim-7.4.tar.bz2</span><br><span class="line">wget ftp://ftp.vim.org/pub/vim/Unix/vim-7.4.tar.bz2</span><br><span class="line"></span><br><span class="line">tar xjvf vim-7.4.tar.bz2</span><br><span class="line">cd vim74</span><br></pre></td></tr></table></figure>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>vim的编译其实很简单，就configure-&gt;make-&gt;make install 这样的流程。但是要添加 Lua支持，就有一些麻烦了。</p>
<p>configure的配置大概是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./configure --prefix=/data/vim74 --with-features=huge --with-luajit --enable-luainterp=yes</span><br></pre></td></tr></table></figure>
<p>首先如果不在 configure配置那手动打开 <code>--enable-fail-if-missing</code> 这个选项，你会发现，configure没有问题，make没有问题，make install也OK，但是运行生成的vim： <code>vim --version</code>会发现Lua前面还是一个”-“（表示没有Lua支持）<br>因为其实configure那根本就没有找到lua的支持，只是默认跳过了 <code>--enable-luainterp=yes</code> 选项。。。<br>所以应该这样运行configure：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./configure --prefix=/data/vim74 --with-features=huge --with-luajit --enable-luainterp=yes --enable-fail-if-missing</span><br></pre></td></tr></table></figure>
<p>如果你的机器没有安装lua 和luajit的话会在检查lua支持那里中断了。</p>
<h3 id="安装Lua和LuaJit"><a href="#安装Lua和LuaJit" class="headerlink" title="安装Lua和LuaJit"></a>安装Lua和LuaJit</h3><p>Lua的安装倒是比较方便，官方repo里面就有，当然要想安装新版的也可以自己编译安装。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum install lua lua-devel -y</span><br></pre></td></tr></table></figure>
<p>luajit不在centos的官方repo里面，我们需要编译安装;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget http://luajit.org/download/LuaJIT-2.0.4.tar.gz</span><br><span class="line">tar -xzvf LuaJIT-2.0.4.tar.gz</span><br><span class="line">cd LuaJIT-2.0.4</span><br><span class="line">// 使用默认安装路径</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
<h2 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h2><p>安装好lua支持后，再运行configure就不会报错了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./configure --prefix=/data/vim74 --with-features=huge --with-luajit --enable-luainterp=yes --enable-fail-if-missing</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>运行编译的vim：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/data/vim74/bin/vim</span><br></pre></td></tr></table></figure>
<p>可能你会发现这样的错误:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/data/vim74/bin/vim: error while loading shared libraries: libluajit-5.1.so.2: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure>
<p>显然是安装的luajit有问题。我们找一下luajit这个.so文件在哪里</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo find / -name libluajit-5.1.so.2</span><br></pre></td></tr></table></figure>
<p>发现下面有这个文件：</p>
<ol>
<li>/home/wuxu/tars/ngx_openresty-1.7.10.2/build/luajit-root/data/openresty/luajit/lib/libluajit-5.1.so.2</li>
<li>/usr/local/lib/libluajit-5.1.so.2</li>
<li>/data/openresty/luajit/lib/libluajit-5.1.so.2</li>
</ol>
<p>显然1，3是openresty编译的，第二个才是我们安装luajit支持，我们需要给这个.so生成一个软链接，让vim能找到它：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo ln -s /usr/local/lib/libluajit-5.1.so.2 /lib64/libluajit-5.1.so.2</span><br></pre></td></tr></table></figure>
<p>这样再运行vim就不会有问题了～也有Lua支持了，不过Vim的自动补全还没用过呢，学会了再做记录吧。</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/effective-go-note-3/" itemprop="url">
                  Effective Go笔记：空白标识符，接口检查与内嵌
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-07-20T12:34:50+08:00" content="2015-07-20">
              2015-07-20
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/programming/" itemprop="url" rel="index">
                    <span itemprop="name">programming</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>effective go 中的部分笔记，这是第三部分 </p>
<p>部分笔记摘要,参考： <a href="https://go-zh.org/doc/effective_go.html" title="https://go-zh.org/doc/effective_go.html" target="_blank" rel="noopener">https://go-zh.org/doc/effective_go.html</a></p>
<h2 id="空白标识符"><a href="#空白标识符" class="headerlink" title="空白标识符"></a>空白标识符</h2><p>空白标识符是指”_”，是一个特殊的变量标识，在之前的for…range 循环中已经使用过。</p>
<h3 id="为未使用的变量或者包使用"><a href="#为未使用的变量或者包使用" class="headerlink" title="为未使用的变量或者包使用"></a>为未使用的变量或者包使用</h3><p>在Go中如果定义了一个变量没有使用，或者导入一个没有使用的包会在编译时报错，未使用的包会让程序体积变大并拖慢编译速度，初始化了而不是用的变量会留下某种隐患。<br>但是某些时候我们确实需要丢弃一些没有的变量，比如在for range循环中，可能需要丢弃键或者值，或者程序写到中途某些变量已经定义只是还没有使用等等，这时就需要空白标识符了。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 检查某个路径是否存在</span></span><br><span class="line"><span class="keyword">if</span> _, err := os.Stat(paht); os.IsNotExist(err) &#123;</span><br><span class="line">	fmt.Println(<span class="string">"path not exist"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于未使用的变量和未使用的导入包，可以把它们先赋值给空白标识符”_”关闭编译器的错误，在使用了这些变量后再删掉这些代码：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">fd = <span class="number">32</span></span><br><span class="line">....</span><br><span class="line">_ = fd</span><br><span class="line"><span class="keyword">var</span> _ = fmt.Printf  <span class="comment">// 用于调试使用，结束时删除</span></span><br></pre></td></tr></table></figure>
<h2 id="接口检查"><a href="#接口检查" class="headerlink" title="接口检查"></a>接口检查</h2><p>如果只需要判断某个类型是否实现了某个接口而不需要实际使用接口本身，可以使用空白标识符：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if _, ok := val.(Milk); ok &#123;</span><br><span class="line">	fmt.Printf(&quot;value %v has implement interface milk&quot;, val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 接口检查示例</span><br><span class="line">type iMilk interface &#123; </span><br><span class="line">  getName() string</span><br><span class="line">&#125;</span><br><span class="line">type Milk struct &#123; </span><br><span class="line">  name string</span><br><span class="line">&#125;</span><br><span class="line">func (m Milk) getName() string &#123;</span><br><span class="line">  return m.name</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">  var m interface &#123;&#125;</span><br><span class="line">  m = Milk&#123;&quot;yili&quot;&#125;</span><br><span class="line">  if _,ok := m.(iMilk); ok &#123;</span><br><span class="line">    fmt.Printf(&quot;value %v has implement iMilk\n &quot;, m)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    fmt.Println(&quot;has not implememt&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="内嵌-Embedding"><a href="#内嵌-Embedding" class="headerlink" title="内嵌/Embedding"></a>内嵌/Embedding</h2><p>Go语言并不提供典型的类与继承系统，所以也没有子类化的概念。继承是一个重要的概念，但是很多时候更推荐的做法是使用组合，Go提供的内嵌和组合概念差不多，可以将类型<strong>内嵌</strong>到结构体或者接口中，实现某种组合功能。</p>
<p>一种典型的内嵌的ReadWriter接口的定义：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">	Read(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">	Write(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 一个结合了Reader和Writer的接口</span></span><br><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">	Reader</span><br><span class="line">	Writer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以内嵌到一个结构体中</span></span><br><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">struct</span> &#123;</span><br><span class="line">	r *Reader</span><br><span class="line">	w *Writer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内嵌的接口一般需要实现被内嵌接口的方法，满足其需求，比如要提供Read方法：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(re *ReadWriter)</span> <span class="title">Read</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> rw.r.Read(p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而通过直接内嵌结构体，我们就能避免如此繁琐。 <strong>内嵌类型的方法可以直接引用</strong>。<br>当内嵌一个类型时，该类型的方法会成为外部类型的方法， 但当它们被调用时，该方法的接收者是内部类型，而非外部的。在我们的例子中，当 bufio.ReadWriter 的 Read 方法被调用时， 它与之前写的转发方法具有同样的效果；接收者是 ReadWriter 的 reader 字段，而非 ReadWriter 本身：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type Logger struct &#123;</span><br><span class="line">  content string</span><br><span class="line">&#125;</span><br><span class="line">func (l Logger) Log(s string) &#123;</span><br><span class="line">  l.content += s</span><br><span class="line">  fmt.Println(s)</span><br><span class="line">&#125;</span><br><span class="line">type infoLog struct &#123;</span><br><span class="line">  count int</span><br><span class="line">  *Logger</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">	var logger = infoLog&#123;0, &amp;Logger&#123;&quot;sss&quot;&#125; &#125;</span><br><span class="line">	// 可以直接调用内嵌类型的方法</span><br><span class="line">	logger.Log(&quot;embedding function invoke&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内嵌类型可能会引起命名冲突的问题。更深层次的命名字段或方法会被覆盖。若相同的嵌套层级上出现同名冲突，通常会产生一个错误。但是如果冲突的名字不会被使用就没有问题……</p>
<p><em>并发部分有点多，单独做一篇吧</em></p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/vim-shortcuts/" itemprop="url">
                  vim 常用的快捷键
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-07-19T12:34:50+08:00" content="2015-07-19">
              2015-07-19
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>vim作为键盘操作为主的编辑器，有许多功能丰富的快捷键，其实不只在普通模式下有快捷键，其实在插入模式下也有一些有用的快捷键…</p>
<h2 id="插入模式的快捷键"><a href="#插入模式的快捷键" class="headerlink" title="插入模式的快捷键"></a>插入模式的快捷键</h2><p>对于新手来说，vim的插入模式和记事本一样“好用”，记事本有一些快捷键，但是在vim的插入模式下，我们却经常忘记使用快捷键：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;C-h&gt;/Ctrl+h	 删除前一个字符</span><br><span class="line">&lt;C-w&gt;			删除前一个单词</span><br><span class="line">&lt;C-u&gt;			删除到行首</span><br><span class="line"></span><br><span class="line">Esc/&lt;C-[&gt;	Esc进入普通模式，其实Ctrl+[和Esc的作用是一样的</span><br><span class="line">&lt;Ctrl-o&gt;		Ctrl+o进入插入-普通模式，此模式下可以执行一个普通模式下的命令并返回插入模式，</span><br><span class="line">			常用 &lt;C-o&gt;zz：保持插入模式并把光标行滚动到屏幕中间</span><br></pre></td></tr></table></figure>
<p>可以在插入模式下使用vim的计算工具<code>&lt;C-r&gt;=</code> 插入模式下这个组合键访问表达式寄存器(=)，这是会在屏幕下方提示输入运算符，输入<code>1+2+3</code> 后 <code>&lt;CR&gt;</code>（回车），vim就会把运算结果插入到刚刚的光标位置，并且仍然是插入模式</p>
<p>对于104键的键盘可以在插入模式下使用<code>Shift+insert</code>组合键粘贴系统剪切板的内容，可以使用<code>&lt;C-r&gt;n</code>粘贴寄存器n中的内容</p>
<p>在插入模式下 <code>&lt;C-v&gt;</code>用来插入一个特殊字符，比如<code>&lt;C-v&gt;u00bf</code>可以插入一个返过来的问号~这是用来插入unicode字符的。</p>
<h2 id="可视模式下的快捷键"><a href="#可视模式下的快捷键" class="headerlink" title="可视模式下的快捷键"></a>可视模式下的快捷键</h2><h2 id="普通模式下的快捷键"><a href="#普通模式下的快捷键" class="headerlink" title="普通模式下的快捷键"></a>普通模式下的快捷键</h2><h2 id="分栏"><a href="#分栏" class="headerlink" title="分栏"></a>分栏</h2><p><code>sp {filename}</code> 水平切分上下两栏。filename可选，默认当前文件，快捷键<code>&lt;C-w&gt;s</code><br><code>vsp {filenamem}</code> 垂直切分，左右两栏 <code>&lt;C-w&gt;v</code></p>
<p>如果安装了yadr扩展的话可以使用<code>contrl+h,j,k,l</code>来跳转到相应方向的分栏<br>没有yadr可以使用快捷键 <code>&lt;C-w&gt;&lt;C-w&gt;</code>在分栏中循环切换，或这使用<code>&lt;C-w&gt;[h,j,k,l]</code> 跳转到分栏。</p>
<p><code>&lt;C-w&gt;=</code> 所有窗口等宽等高<br><code>&lt;C-w&gt;_</code> 最大化活动窗口高度<br><code>&lt;C-w&gt;|</code> 最大化活动窗口宽度<br><code>[n]&lt;C-w&gt;_</code> 活动窗口高度设为n<br><code>[n]&lt;C-w&gt;|</code> 活动窗口宽度设为n</p>
<p><code>:clo</code> 关闭活动窗口， 快捷键 <code>&lt;C-w&gt;c</code><br><code>:on[ly]</code> 只保留当前窗口   快捷键 <code>&lt;C-w&gt;o</code></p>
<p>很有用的重新对其代码,命令模式下 <code>gg=G</code><br><em>待续</em></p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/compile-and-install-php7-beta1/" itemprop="url">
                  编译安装PHP7 beta1
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-07-19T12:34:50+08:00" content="2015-07-19">
              2015-07-19
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/server/" itemprop="url" rel="index">
                    <span itemprop="name">server</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <p>前段时间去php.net上闲逛发现PHP7的beta1版本出来了，就尝试着编译安装了一下</p>
<p>之前在鸟哥的博客里看到了他们做的PHP的性能测试，相对于PHP5.6都是有很大的提升的，并且PHP的主版本号已经是2004年发布PHP5后，11年来首次更新，肯定PHP７是有很大的改变的，下面那就来试试PHP7的beta版吧，正式版大概在今年年底会发布。</p>
<h2 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h2><p>测试版本的PHP下载页面： <a href="https://downloads.php.net/~ab/" title="https://downloads.php.net/~ab/" target="_blank" rel="noopener">https://downloads.php.net/~ab/</a></p>
<p>php7 beta1: <a href="https://downloads.php.net/~ab/php-7.0.0beta1.tar.gz" title="https://downloads.php.net/~ab/php-7.0.0beta1.tar.gz" target="_blank" rel="noopener">https://downloads.php.net/~ab/php-7.0.0beta1.tar.gz</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https://downloads.php.net/~ab/php-7.0.0beta1.tar.gz</span><br><span class="line">或者</span><br><span class="line">curl -O https://downloads.php.net/~ab/php-7.0.0beta1.tar.gz</span><br></pre></td></tr></table></figure>
          <div class="post-more-link text-center">
            <a class="btn" href="/compile-and-install-php7-beta1/" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/effective-go-note-2/" itemprop="url">
                  Effective Go笔记：方法，接口与其他类型
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-07-19T12:34:50+08:00" content="2015-07-19">
              2015-07-19
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/programming/" itemprop="url" rel="index">
                    <span itemprop="name">programming</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>effective go 中的部分笔记，这是第二部分 </p>
<p>部分笔记摘要,参考： <a href="https://go-zh.org/doc/effective_go.html" title="https://go-zh.org/doc/effective_go.html" target="_blank" rel="noopener">https://go-zh.org/doc/effective_go.html</a></p>
<h2 id="方法-Methods"><a href="#方法-Methods" class="headerlink" title="方法/Methods"></a>方法/Methods</h2><p>与一般的面向对象语言不同；一般的面向对象语言定义类，然后在类中定义属性和方法，通过类的继承来抽象一套机制，但是在Go中，首先是定义结构，然后为已经命名的结构（除了指针或接口）定义方法，这里有一个方法接收者的概念，为一个结构体绑定方法的常用用法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type Book struct &#123;</span><br><span class="line">	price float64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (p Book) Disount(c float64) float64 &#123;</span><br><span class="line">	// 注意int和float64类型不一样，</span><br><span class="line">	// 在Go中并不能直接操作，需要进行类型转换</span><br><span class="line">	// 但是float64 可以与字面量值直接相乘... p.price*100不会有问题</span><br><span class="line">	return p.price * c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对一些方法，传入的参数是值的拷贝而不是地址，经常需要在方法的结尾放回新的结果，可以通过把参数的指针传入，直接修改参数的地址指向的值，常见的io.Write接口就是在指针添加方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type byteSlice []byte</span><br><span class="line">func (slice *byteSlice) Write(data []byte) (n int, err error) &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var b byteSlice</span><br><span class="line">fmt.Fprintf(&amp;b, &quot;this is a string&quot;, 7)</span><br></pre></td></tr></table></figure>
<p><strong>以指针或值为接收者的区别在于：值方法可通过指针和值调用， 而指针方法只能通过指针来调用</strong></p>
<h2 id="接口与其他类型-interface"><a href="#接口与其他类型-interface" class="headerlink" title="接口与其他类型/interface"></a>接口与其他类型/interface</h2><p>Go中的接口为指定对象的行为提供了一种方法：<strong>如果某样东西可以完成这个， 那么它就可以用在这里。</strong>我们已经见过许多简单的示例了；通过实现 String 方法，我们可以自定义打印函数，而通过 Write 方法，Fprintf 则能对任何对象产生输出。</p>
<p>Go中的的接口只是需要实现它的类接受了同名的方法即可，这是很特别的。</p>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type squence []int</span><br><span class="line">func (s squence) String stirng &#123;</span><br><span class="line">	// do some thing to s</span><br><span class="line">	return ftm.Sprint(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果忽略类型名，squence和[]int其实是相同的，只不过squence有一个新的类型名而已，所以在他们之间进行类型转换是可以的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">is := []int(s)</span><br></pre></td></tr></table></figure>
<p>在Go语言中，为了访问不同的方法集会经常进行类型转换。甚至对int和float之间的简单运算都会用到类型转换。</p>
<h3 id="接口转换与类型断言"><a href="#接口转换与类型断言" class="headerlink" title="接口转换与类型断言"></a>接口转换与类型断言</h3><p>对于混合类型，我们经常需要将一种接口转换为另一种接口，要判断一个值是否实现了某个接口，需要使用到<strong>类型断言</strong>。类型断言接受一个接口值，并从中提取指定的明确的明确类型的值。与其他语言判断类型不同，它的用法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var.(typeName)</span><br><span class="line">str.(string)</span><br><span class="line"></span><br><span class="line">// 对于使用接口定义的值，可以使用下面的方式</span><br><span class="line">// 其中iv是用 var iv interface&#123;&#125; 定义的，Milk是一中类型</span><br><span class="line">switch str := iv.(type) &#123;</span><br><span class="line">case string:</span><br><span class="line">  fmt.Println(str)</span><br><span class="line">case Milk:</span><br><span class="line">  fmt.Println(&quot;milk&quot;, str)</span><br><span class="line">default:</span><br><span class="line">  fmt.Println(&quot;interface type:&quot;, str)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个看起来很奇怪的用法，不知道Go中有没有提供想instanceof这样的关键字。</p>
<h3 id="通用性-Generality"><a href="#通用性-Generality" class="headerlink" title="通用性/Generality"></a>通用性/Generality</h3><blockquote>
<p>这部分还不是很了解</p>
</blockquote>
<p>若某种现有的类型仅实现了一个接口，且除此之外并无可导出的方法，则该类型本身就无需导出。 仅导出该接口能让我们更专注于其行为而非实现，其它属性不同的实现则能镜像该原始类型的行为。 这也能够避免为每个通用接口的实例重复编写文档。</p>
<p>在这种情况下，构造函数应当返回一个接口值而非实现的类型。</p>
<h2 id="接口和方法"><a href="#接口和方法" class="headerlink" title="接口和方法"></a>接口和方法</h2><p>Go中几乎任何类型(<strong>除了指针和接口</strong>)都能添加方法（添加的示例已经看过很多了，就不赘述了），因此几乎任何类型都能满足一个接口（即使是基于int的类型也能用来满足一个特别的接口），常见的用法就是<strong>任何实现了ServeHTTP方法的对象都能处理HTTP请求</strong>。</p>
<blockquote>
<p>甚至可以为func添加方法，当然需要先将函数定义为一种新类型</p>
</blockquote>
<p>Handler接口定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type Handler interface &#123;</span><br><span class="line">	ServeHTTP(ResponseWriter, *Request)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是一个实现该接口的示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &quot;net/http&quot;</span><br><span class="line"></span><br><span class="line">type milkServer struct &#123;</span><br><span class="line">	n int</span><br><span class="line">&#125;</span><br><span class="line">// 注意参数中的http不能少，参考Go的包机制</span><br><span class="line">func (m *MilkServer) ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line">	m.n++</span><br><span class="line">	// do some thing</span><br><span class="line">	fmt.Fprintf(w, &quot;request count at %d\n&quot;, m.n)</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 添加绑定</span><br><span class="line">m := new(Milk)</span><br><span class="line">http.Handle(&quot;/count&quot;, m)</span><br><span class="line">// 也可以直接绑定一个与ServeHTTP签名相同的函数</span><br><span class="line">func ArgsFunc(w http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line">http.HandleFunc(&quot;args&quot;, ArgsFunc)</span><br></pre></td></tr></table></figure>
<p>当然也可以绑定到一个信道上面，然后使用信道新更新一些内部状态：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type Chan chan *http.Request</span><br><span class="line">func (c Chan) ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line">	c &lt;- req</span><br><span class="line">	fmt.Fprint(w, &quot;request received&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/vim-commands/" itemprop="url">
                  vim 常用的命令模式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-07-18T12:34:50+08:00" content="2015-07-18">
              2015-07-18
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>vim中常用的命令，日常更新 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">!ls  使用感叹号开头调用系统命令</span><br><span class="line">~	 切换当前光标所在字符的大小写</span><br></pre></td></tr></table></figure>
<h2 id="buffer相关"><a href="#buffer相关" class="headerlink" title="buffer相关"></a>buffer相关</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:ls</span><br><span class="line">:bn :bnext</span><br><span class="line">:bp :bprev</span><br><span class="line">:bd :bdelete</span><br><span class="line">:b1 :buffer1</span><br><span class="line">:bufdo cmd 在所有缓冲区执行命令</span><br></pre></td></tr></table></figure>
<h2 id="参数列表"><a href="#参数列表" class="headerlink" title="参数列表"></a>参数列表</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:args 列出参数列表或者设置参数列表</span><br><span class="line">:args **/*.postfix</span><br><span class="line">:write :w</span><br><span class="line">:edit! :e!放弃修改重新载入文件</span><br><span class="line">:qall :qa</span><br><span class="line">:wall :wa</span><br></pre></td></tr></table></figure>
<h2 id="多窗口"><a href="#多窗口" class="headerlink" title="多窗口"></a>多窗口</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:sp [file] 水平分割</span><br><span class="line">:vsp [filw] 垂直分割</span><br><span class="line">:clo &lt;C-w&gt;c 关闭当前窗口</span><br><span class="line">:no[ly] &lt;C-v&gt;o 关闭当前之外的所有窗口</span><br></pre></td></tr></table></figure>
<p><strong>切换窗口</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;C-w&gt;&lt;C-w&gt; 在串口中切换，连续按两次Ctrl+w</span><br><span class="line">&lt;C-w&gt;h|j|k|l 切换到左/下/上/右的窗口</span><br></pre></td></tr></table></figure>
<p><strong>改变窗口大小</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;C-w&gt;=</span><br><span class="line">&lt;C-w&gt;_  最大化当前窗口的高度</span><br><span class="line">&lt;C-w&gt;|  最大化当前窗口的宽度</span><br><span class="line">[n]&lt;C-w&gt;_   设置</span><br><span class="line">[n]&lt;C-w&gt;|</span><br></pre></td></tr></table></figure>
<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:tabedit :tabe &#123;filename&#125; 如果filename为空则打开一个新的标签页</span><br><span class="line">:tabclose :tabc </span><br><span class="line">:tabonly  :tabo  关闭当前标签之外的所有标签</span><br></pre></td></tr></table></figure>
<p><strong>标签切换</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:tabnext  :tabn &#123;N&#125;  Ngt</span><br><span class="line">:tabn gt</span><br><span class="line">:tabp gT</span><br><span class="line">:tabmove [N] 移动标签页</span><br></pre></td></tr></table></figure>
<h2 id="打开及保存文件"><a href="#打开及保存文件" class="headerlink" title="打开及保存文件"></a>打开及保存文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:edit full/path/name</span><br><span class="line">:edit %:h&lt;tab&gt;filename 	使用缓冲区文件的完整路径打开文件, :h去掉当前文件名，tab键补全</span><br><span class="line">:edit path 打开文件管理窗口</span><br><span class="line">:find filename 在path下查找文件</span><br><span class="line">: set path+=/path/to/workspace  将工作区添加到vim的path中用于寻找</span><br><span class="line">:e 是 :edit的缩写</span><br><span class="line">:Explore :E 打开当前的目录管理器</span><br><span class="line">:Sexplore  explore的切分</span><br><span class="line">:Vexplore</span><br></pre></td></tr></table></figure>
<p><strong>文件操作</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:!mkdir -p %:h    前缓冲区创建目录，然后在:w，解决某些不能保存的问题</span><br><span class="line">:w !sudo tee % &gt; /dev/null 由于保存用非sudo打开的无权限文件的保存</span><br></pre></td></tr></table></figure>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/effective-go-note-1/" itemprop="url">
                  Effective Go笔记：函数，数据，初始化
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-07-18T12:34:50+08:00" content="2015-07-18">
              2015-07-18
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/programming/" itemprop="url" rel="index">
                    <span itemprop="name">programming</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <p>effective go 中的部分笔记，这是第一部分 </p>
<p>部分笔记摘要,参考： <a href="https://go-zh.org/doc/effective_go.html" title="https://go-zh.org/doc/effective_go.html" target="_blank" rel="noopener">https://go-zh.org/doc/effective_go.html</a></p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>Go的函数有一个很特别的性质那就是多值返回，这样做有一个很方便的地方是可以把错误值返回，这样做和后面会讲到的取消异常也是有关的。</p>
<p>一个Go函数的签名可能是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func (file *File) Write(b []byte) (n int, err error)</span><br></pre></td></tr></table></figure>
<p>这是一个典型的Go函数签名，初看起来比较复杂，一点点分析：</p>
<ol>
<li>func关键字，类似php中的function</li>
<li>(file <em>File) 表示这是一个添加到</em>File接口上的方法。这也是Go比较有意思的地方，通过<em>附着</em>接口方法的方式实现接口</li>
<li>Write 很简单就是方法名了，大写开头的方法表示共有的导出方法，如果是小写的方法名是不能导出的</li>
<li>(b []byte)方法的参数，形参名为b，类型为[]byte</li>
<li>(n int, err error) 返回类型，如果是多指返回则使用小括号括起来，如果是一个返回值就不需要了。比较有意思的是返回值也可以作为有命名返回值，比如这里的n和err，这样表示把函数作用域内的n和err变量返回，这样返回语句只需要写return，而不需要显式说明具体变量</li>
</ol>
<h3 id="Defer"><a href="#Defer" class="headerlink" title="Defer"></a>Defer</h3><p>Defer 是Go的关键字，用于预设一个函数调用，一个使用Defer调用的函数会<strong>在执行defer的函数返回之前</strong>立即执行，常用来释放资源，比如解锁互斥和关闭文件<br>使用defer推迟的函数会按照<strong>后进先出</strong>的顺序执行。<br>
          <div class="post-more-link text-center">
            <a class="btn" href="/effective-go-note-1/" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/go-iota-spc/" itemprop="url">
                  Golang 中iota的用法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-07-18T12:34:50+08:00" content="2015-07-18">
              2015-07-18
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/programming/" itemprop="url" rel="index">
                    <span itemprop="name">programming</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>Golang中可以使用iota方便的定义复杂的常量结构，下面是golang spec中的说明</p>
<p>Within a constant declaration, the predeclared identifier iota represents successive untyped integer constants. It is reset to 0 whenever the reserved word const appears in the source and increments after each ConstSpec. It can be used to construct a set of related constants:</p>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const (  // iota is reset to 0</span><br><span class="line">	c0 = iota  // c0 == 0</span><br><span class="line">	c1 = iota  // c1 == 1</span><br><span class="line">	c2 = iota  // c2 == 2</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">	a = 1 &lt;&lt; iota  // a == 1 (iota has been reset)</span><br><span class="line">	b = 1 &lt;&lt; iota  // b == 2</span><br><span class="line">	c = 1 &lt;&lt; iota  // c == 4</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">	u         = iota * 42  // u == 0     (untyped integer constant)</span><br><span class="line">	v float64 = iota * 42  // v == 42.0  (float64 constant)</span><br><span class="line">	w         = iota * 42  // w == 84    (untyped integer constant)</span><br><span class="line">)</span><br><span class="line">``</span><br><span class="line">const x = iota  // x == 0 (iota has been reset)</span><br><span class="line">const y = iota  // y == 0 (iota has been reset)</span><br></pre></td></tr></table></figure>
<p>Within an ExpressionList, the value of each iota is the same because it is only incremented after each ConstSpec:</p>
<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const (</span><br><span class="line">	bit0, mask0 = 1 &lt;&lt; iota, 1&lt;&lt;iota - 1  // bit0 == 1, mask0 == 0</span><br><span class="line">	bit1, mask1                           // bit1 == 2, mask1 == 1</span><br><span class="line">	_, _                                  // skips iota == 2</span><br><span class="line">	bit3, mask3                           // bit3 == 8, mask3 == 7</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>This last example exploits the implicit repetition of the last non-empty expression list.</p>
<p>iota是一个比较有特色的东西，看完这两个例子基本就知道怎么用了，相当于它是一个从0开始自动增加的变量，可以重复使用，可以用来定义单位的大小，比如KB，MB，GB等</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/using-ambari-to-setup-a-hadoop-cluster/" itemprop="url">
                  使用ambari搭建并管理一个hadoop集群
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-04-27T12:34:50+08:00" content="2015-04-27">
              2015-04-27
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/server/" itemprop="url" rel="index">
                    <span itemprop="name">server</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <p>这部分包含的内容：</p>
<ol>
<li>什么是ambari</li>
<li>如何安装Ambari</li>
<li>安装hadoop集群的准备工作</li>
<li>如何使用Ambari搭建一个集群</li>
<li>其他</li>
</ol>
<h2 id="什么是Ambari"><a href="#什么是Ambari" class="headerlink" title="什么是Ambari"></a>什么是Ambari</h2><p><a href="http://ambari.apache.org/" target="_blank" rel="noopener">Ambari</a>是的apache基金会下的一个开源项目。其目标是简化Hadoop集群的管理。通过Ambari提供工具可以方便的配置、管理、监控Hadoop集群。Ambari提供了一个直观的，易用的Hadoop管理web界面。Ambari现在最新的版本为2.0.0，但是网上比较多的资料都是1.2-1.7的。</p>
<p>作为一个开源项目，Hadoop在的配置与管理一直非常的不友好，要配置一个Hadoop集群经常会出现各种问题，并且对于集群的监控也比较麻烦，这也是像cloudera、hortonworks这类的提供Hadoop服务的公司可以存在的理由。</p>
<p>Ambari架构采用的是Server/Client的模式，主要组件：ambari-agent、ambari-server和ambari-web。ambari-agent是一个无状态的， 采集所在节点的信息并且汇总发心跳汇报给ambari-server， 处理ambari-server的执行请求。<br>
          <div class="post-more-link text-center">
            <a class="btn" href="/using-ambari-to-setup-a-hadoop-cluster/" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    

  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/16/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><span class="page-number current">17</span>
  </nav>



        </div>

        


        

      </div>

      
        
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="/images/avatar.jpg" alt="wuxu" itemprop="image"/>
          <p class="site-author-name" itemprop="name">wuxu</p>
        </div>
        <p class="site-description motion-element" itemprop="description">Wu Xu的个人博客</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">170</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">24</span>
              <span class="site-state-item-name">分类</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">148</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/wuxu92" target="_blank">
                  
                    <i class="fa fa-github"></i> GitHub
                  
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/wuxu92" target="_blank">
                  
                    <i class="fa fa-twitter"></i> Twitter
                  
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/kiwidock" target="_blank">
                  
                    <i class="fa fa-weibo"></i> Weibo
                  
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://douban.com/people/wuxu92" target="_blank">
                  
                    <i class="fa fa-douban"></i> Douban
                  
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.zhihu.com/people/wuxu92" target="_blank">
                  
                    <i class="fa fa-zhihu"></i> Zhihu
                  
                </a>
              </span>
            
          
        </div>

        
        
          <div class="cc-license motion-element" itemprop="license">
            <a href="http://creativecommons.org/licenses/by-nc-sa/4.0" class="cc-opacity" target="_blank">
              <img src="/images/cc-by-nc-sa.svg" alt="Creative Commons" />
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


      
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2014 - 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="icon-next-heart fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wuxu</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  

  
    
    

  


  

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.2"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.2"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
<script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

<script type="text/javascript" src="/js/motion.js?v=0.4.5.2" id="motion.global"></script>


  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  

  <script type="text/javascript" src="/js/bootstrap.js"></script>

  
  

  
  

</body>
</html>
