<!doctype html>
<html class="theme-next ">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="google-site-verification" content="h7BaHlqi6VjlciSt0RF-KHgIXZcGfx3L3gyQ9qfx_ek" />










  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.4.5.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="wuxu, Golang, C, CPP, CS, PHP, " />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.2" />






<meta name="description" content="Wu Xu的个人博客">
<meta property="og:type" content="website">
<meta property="og:title" content="Wu Xu">
<meta property="og:url" content="http://blog.wuxu92.com/page/16/index.html">
<meta property="og:site_name" content="Wu Xu">
<meta property="og:description" content="Wu Xu的个人博客">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Wu Xu">
<meta name="twitter:description" content="Wu Xu的个人博客">



<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: '',
    sidebar: 'hide',
    motion: false
  };
</script>

  <title> Wu Xu </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-72131273-1', 'auto');
  ga('send', 'pageview');
</script>





  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>
    <div class="bottomband"></div> <!-- add by wuxu -->
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Wu Xu</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">关注C、Go、C++、JavaScript和UX</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th fa-fw"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-user fa-fw"></i> <br />
            
            关于
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content">
          
  <section id="posts" class="posts-expand">

    

    
    
      
      

      
    

    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/using-sed-tool-process-text/" itemprop="url">
                  使用sed处理文本
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-08-21T12:34:50+08:00" content="2015-08-21">
              2015-08-21
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>Linux的文本处理工具除了awk之外，还有一个利器，那就是sed。sed用于文本的替换，也是以行为单位，使用正则表达式进行匹配。</p>
<p>参考： <a href="http://coolshell.cn/articles/9104.html" title="http://coolshell.cn/articles/9104.html" target="_blank" rel="noopener">http://coolshell.cn/articles/9104.html</a></p>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>sed的命令模式是这样的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -i <span class="string">'sed-command'</span> file-to-process</span><br></pre></td></tr></table></figure>
<p>其中，-i参数是很常用的，如果不带-i参数处理的结果会在终端打印出来，带上-i参数后会将处理结果<strong>替换输入文件</strong>的内容。</p>
<p>中间引号内的是sed的命令内容，常用单引号，但是要注意在单引号里面，反斜杠()转义将不能起作用。命令常用模式为 <code>s/old-pattern/new-str/g</code><br>最后的是要处理的文本的文件名。</p>
<p>由于sed主要依赖正则匹配实现功能，所以先熟悉一下基础的正则规则：</p>
<ul>
<li>^ 表示一行的开头。如：<code>/^#/</code> 以#开头的匹配。</li>
<li>$ 表示一行的结尾。如：<code>/}$/</code> 以}结尾的匹配。</li>
<li><code>\&lt;</code> 表示词首。 如 \&lt;abc 表示以 abc 为首的詞。</li>
<li><code>\&gt;</code> 表示词尾。 如<code>abc\&gt;</code> 表示以 abc 結尾的詞。</li>
<li>. 表示任何单个字符。</li>
<li><code>*</code> 表示某个字符出现了0次或多次。</li>
<li><code>[ ]</code>字符集合。 如：<code>[abc]</code>表示匹配a或b或c，还有<code>[a-zA-Z]</code>表示匹配所有的26个字符。如果其中有<strong>^表示反</strong>，如<code>[^a]</code>表示非a的字符</li>
</ul>
<p>练习：下面的命令可以去掉html文件中的标签，只留下文本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -i <span class="string">"s/&lt;[^&gt;]*&gt;//g"</span> index.html</span><br></pre></td></tr></table></figure>
<p>其中，命令开头的s代表替换，<code>[^&gt;]*</code>表示一个以上的非&gt;字符，替换为空。</p>
<p>上面的命令如果是:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed -i &apos;s/&lt;.*&gt;//g&apos; index.html</span><br></pre></td></tr></table></figure>
<p>看起来也好像能工作，但是， &lt;.*&gt;会匹配最长的尖括号内容，即从文本的第一个&lt; 到最后一个&gt;，这样达不到我们的效果。</p>
<h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><h3 id="指定替换"><a href="#指定替换" class="headerlink" title="指定替换"></a>指定替换</h3><p><strong>替换指定行的内容</strong><br>有时候我们仅需要对某些行进行替换，可以在命令中指定行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 只对第3行进行替换</span></span><br><span class="line">sed -i <span class="string">'3s/me/you/g'</span> file-name</span><br><span class="line"></span><br><span class="line"><span class="comment">#只对第3-6行替换</span></span><br><span class="line">sed -i <span class="string">'3,6s/me/you/g'</span> file-name</span><br></pre></td></tr></table></figure>
<p><strong>指定每一行替换的个数</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 替换每一行的第一个匹配</span></span><br><span class="line">sed -i <span class="string">'s/me/you/1'</span> file-name</span><br><span class="line"></span><br><span class="line"><span class="comment">#替换每一行的第2个匹配</span></span><br><span class="line">sed -i <span class="string">'s/me/you/2'</span> file-name</span><br><span class="line"></span><br><span class="line"><span class="comment">#替换第5个以后的所有匹配</span></span><br><span class="line">sed -i <span class="string">'s/me/you/3g'</span> file-name</span><br></pre></td></tr></table></figure>
<h3 id="多个匹配"><a href="#多个匹配" class="headerlink" title="多个匹配"></a>多个匹配</h3><p>如果要对一行进行两个匹配，可以在命令字符串中使用;分割多个匹配项：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed &apos;1,3s/me/you/g; 3,$s/you/me/g&apos; file-name</span><br><span class="line"># 下面的命令等效</span><br><span class="line">sed -e &apos;1,3s/me/you/g&apos; -e &apos;3,$s/you/me/g&apos; file-name</span><br></pre></td></tr></table></figure>
<p>这样将1-3行的me替换为you，将3到最后一行的you替换为me。</p>
<h3 id="圆括号匹配"><a href="#圆括号匹配" class="headerlink" title="圆括号匹配"></a>圆括号匹配</h3><p>类似于正则表达式中的分组，在s中使用的括号，可以在替换串中使用\1,\2指代<br>比如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed <span class="string">'s/This is your \([^,]*\),.*is \(.*\)/\1,\2/g'</span> cats.txt</span><br></pre></td></tr></table></figure>
<p>注意括号部分表示匹配项，括号需要使用斜杠<code>\</code>转义。这与一些编程语言中的规约不一样，一般来说使用$1, $2来指代匹配项。</p>
<h2 id="sed的命令"><a href="#sed的命令" class="headerlink" title="sed的命令"></a>sed的命令</h2><p>sed工具有一些工具用来操作文本，比如在指定行插入行:</p>
<h3 id="a-i-命令"><a href="#a-i-命令" class="headerlink" title="a/i 命令"></a>a/i 命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 在第一行后追加一行</span><br><span class="line">sed &quot;1 a This is your mou, you mou&apos;s name is miaomiao&quot; cats.txt</span><br><span class="line">// 在第一行插入一行，即原来的第一行成为第二行</span><br><span class="line">sed &quot;1 i this is ****&quot; cats.txt</span><br><span class="line">//在文件结尾追加一行</span><br><span class="line">sed &quot;$ a this is ****&quot; cats.txt</span><br><span class="line">// 在所有匹配行后追加一行</span><br><span class="line">sed &quot;/my/a this is my ***&quot; cats.txt</span><br></pre></td></tr></table></figure>
<h3 id="c命令替换匹配行"><a href="#c命令替换匹配行" class="headerlink" title="c命令替换匹配行"></a>c命令替换匹配行</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//替换第二行</span><br><span class="line">sed &quot;c 2 this is my****&quot; cats.txt</span><br><span class="line">// 替换匹配行</span><br><span class="line">sed /my/c this is your****&quot; cats.txt</span><br></pre></td></tr></table></figure>
<h3 id="d命令删除匹配行"><a href="#d命令删除匹配行" class="headerlink" title="d命令删除匹配行"></a>d命令删除匹配行</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 删除第二行</span><br><span class="line">sed &apos;2s&apos; cats.txt</span><br><span class="line">// 删除从第3行到结尾</span><br><span class="line">sed &apos;3,$d&apos; cats.txt</span><br></pre></td></tr></table></figure>
<h3 id="p命令打印输出"><a href="#p命令打印输出" class="headerlink" title="p命令打印输出"></a>p命令打印输出</h3><p>使用p有点类似grep命令，把匹配行输出</p>
<h2 id="处理目录下所有文件"><a href="#处理目录下所有文件" class="headerlink" title="处理目录下所有文件"></a>处理目录下所有文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed -i &apos;2,$s/\t/,\t/g&apos; *</span><br></pre></td></tr></table></figure>
<p>还可以结合grep命令筛选需要处理的文件,这是替换文件内容包含 pattern 的文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed -i &apos;command&apos; `grep -rl pattern ./`</span><br></pre></td></tr></table></figure>
<p>grep的l参数表示只输出文件名，r表示recursive</p>
<p>也可以结合 ls 对文件名筛选：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed -i &apos;command&apos; `ls | grep .txt`</span><br></pre></td></tr></table></figure>
<p>这样就只对 txt 文件执行替换。</p>
<h2 id="待续"><a href="#待续" class="headerlink" title="待续"></a>待续</h2>
            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/example-of-awk-handle-csv/" itemprop="url">
                  一个使用awk处理csv数据示例
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-08-19T12:34:50+08:00" content="2015-08-19">
              2015-08-19
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>最近要处理一个csv文件，起始是这样的：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>mmid</th>
<th>cp</th>
</tr>
</thead>
<tbody>
<tr>
<td>zy006</td>
<td>2200112411</td>
<td>小米商城</td>
</tr>
<tr>
<td>zy007</td>
<td>2200123091-3003904564</td>
<td>掌游自有渠道</td>
</tr>
<tr>
<td>zy008</td>
<td>0</td>
<td>MM应用商城</td>
</tr>
<tr>
<td>zy101</td>
<td>2200131184-2200131784</td>
<td>多酷</td>
</tr>
<tr>
<td>zy102</td>
<td>2200017122-2200126498-2200127284-3003898651</td>
<td>3G门户</td>
</tr>
<tr>
<td>zy104</td>
<td>3003904473</td>
<td>软吧</td>
</tr>
</tbody>
</table>
<p>第二列是多个元素组合起来的，现在要导入到数据库里面，把第一列和第二列的元素使用一个关联表而不是这样使用数据拼接的方式。</p>
<p>要处理的结果是抽出第一列和第二列，然后第二列使用’-‘分割新建一条记录。</p>
<p>步骤如下：</p>
<p>1 抽出数据到新文件:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk -F <span class="string">","</span> <span class="string">'NR&gt;1&#123;printf("%s,%s\n", $1, $2)&#125;'</span> data.csv&gt; mmid.csv</span><br></pre></td></tr></table></figure>
<p>NR代表当前的记录的数值，表示第几个记录了，这里忽略掉第一行。</p>
<p>2 分割数据并创建新记录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk -F <span class="string">'[,-]'</span> <span class="string">'&#123;for(i=2;i&lt;NF;i++) &#123;printf("%s,%s\n", $1, $i)&#125;&#125;'</span> mmid.csv &gt; channel_mmid.csv</span><br></pre></td></tr></table></figure>
<p>使用-F 设置两个分割参数，使用一个循环，其中NF是number of fields的简写，表名当前当有多少条记录，对应有NR，number of record</p>
<p>3 完成</p>
<p>使用awk处理excel/csv文件真的非常的方便</p>
<p>4 扩展</p>
<p>删除记录中的某一列</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk -F <span class="string">','</span> <span class="string">'BEGIN&#123;OFS=","; &#125; NR&gt;1&#123;str=""; for (i=1; i&lt;=NF;i++) if (i != 2) str = str "," $i; print str&#125;'</span> channel-manage.csv &gt; new-channel-manage.csv</span><br></pre></td></tr></table></figure>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/write-your-first-php-extension/" itemprop="url">
                  编写你的第一个PHP扩展模块(一)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-08-18T12:34:50+08:00" content="2015-08-18">
              2015-08-18
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Programming/" itemprop="url" rel="index">
                    <span itemprop="name">Programming</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>一直以来对于PHP的扩展编写都比较感兴趣但是却没有什么更深的接触，正好最近要研究一下，做个记录吧。</p>
<p>参考：<br><a href="http://www.laruence.com/2009/04/28/719.html" title="http://www.laruence.com/2009/04/28/719.html" target="_blank" rel="noopener">http://www.laruence.com/2009/04/28/719.html</a><br><a href="http://www.walu.cc/phpbook/5.md" title="http://www.walu.cc/phpbook/5.md" target="_blank" rel="noopener">http://www.walu.cc/phpbook/5.md</a></p>
<p>首先我们从头安装一个PHP环境，现在最新的稳定版的PHP是5.6.12。</p>
<h2 id="编译安装php"><a href="#编译安装php" class="headerlink" title="编译安装php"></a>编译安装php</h2><p>以下在Linux（centos）下完成</p>
<ol>
<li>下载src： <code>wget http://cn2.php.net/get/php-5.6.12.tar.bz2/from/this/mirror</code> wget 下载的文件可能被命名为mirror，需要重命名一下 <code>mv mirror php-5.6.12.tar.bz2</code></li>
<li>解压： <code>tar xjvf php-5.6.12.tar.bz2</code></li>
<li><code>cd php-5.6.12</code> 编译安装： <code>./configure --prefix=/home/wuxu/data/php5.6/ --enable-debug --enable-maintainer-zts</code></li>
<li><code>make</code></li>
<li><code>make install</code></li>
<li><code>make clean</code></li>
</ol>
<p>这样一个新的php安装在了家目录下（/home/wuxu/data/php5.6）。</p>
<h2 id="扩展的准备工作"><a href="#扩展的准备工作" class="headerlink" title="扩展的准备工作"></a>扩展的准备工作</h2><p>首先要理解为PHP内核编写的扩展的两个工作方式，一种是编译为动态共享对象/可装载模块，也就是常见的.so扩展，这种扩展可以在php的配置文件中方便的开启或者关闭；另外一种方式是静态编译到PHP中，使用静态方法编译比较容易上手，鸟哥的文章中也是使用的静态编译方式，所以我们也使用静态编译方式来练习。</p>
<p>PHP在源码中提供了一个扩展骨架构造脚本： ext_skel，脚本放在php-5.6.12/ext目录下。它的使用方式如下： </p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">./ext_skel --extname=mfs --proto=mfs.def</span><br></pre></td></tr></table></figure>
<p>解释一下，–extname明显就是我们要创建的扩展的名称，–proto的proto是prototype的缩写，也就是扩展对外提供的函数原型，可以在这个文件中添加要导出的函数签名，每个函数做一行，这样ext_skel脚本可以自动创建它们的骨架代码。比如鸟哥的例子中的字符串复制函数:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string self_concat(string str, int n)</span><br></pre></td></tr></table></figure>
<p>把这一行保存为mfs.def文件，放在ext文件夹下。</p>
<h2 id="基本骨架"><a href="#基本骨架" class="headerlink" title="基本骨架"></a>基本骨架</h2><p>运行上面的ext_skel命令，就会在ext文件夹下创建一个mfs的文件夹，并声称一些代码文件和配置文件。 php扩展在Linux下的配置文件是 ext/mfs/config.m4；m4有自己的语法，不过我们并不需要熟悉它，只需要简单去掉一些注释就可以了。打开配置文件config.m4；大概在16行和18行，找到<code>PHP_ARG_ENABLE(mfs, whether to enable mfs support</code> 相关的内容，这一行是用来重新生成configure文件时起作用的，取消这一行及<br>它后面的第二行<code>[ --enable-myfunctions                Include myfunctions support])</code>，中间有一行不要取消注释。这样就可以重新生成configure文件可以使用enable-mfs来静态编译扩展。</p>
<p>完成上面的工作后，重新生成configure文件并编译安装php。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /path/to/php-5.6.12</span><br><span class="line">./buildconf --force</span><br><span class="line">./configure --enable-fms --prefix=/home/wuxu/data/php5.6 --with-config-file-path=/home/wuxu/data/etc/php.ini</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>这样编译的php就带有了fms扩展，并可以使用在def文件中定义的原型函数。但是由于并没有编写那个函数的具体内容，所以这个是str_concat函数并不能起作用，不过ext_skel脚本还导出了一个函数： confirm_mfs_compiled(str); 可以用下面的脚本检测fms扩展是否可用了：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">print</span> confirm_mfs_compiled(<span class="string">"myextension"</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// output: </span></span><br><span class="line"><span class="comment">// "Congratulations! You have successfully modified ext/mfs</span></span><br><span class="line"><span class="comment">//  </span></span><br><span class="line"><span class="comment">// config.m4. Module mfs is now compiled into PHP."</span></span><br></pre></td></tr></table></figure>
<p>表明脚本已经编译到php了。下面我们就可以开始编写self_concat的具体内容了。</p>
<h2 id="起始代码"><a href="#起始代码" class="headerlink" title="起始代码"></a>起始代码</h2><p>先看一下有ext_skel脚本自动生成的self_concat函数代码，在ext/mfs/mfs.c:76 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PHP_FUNCTION(self_concat)</span><br><span class="line">&#123;</span><br><span class="line">	char *str = NULL;</span><br><span class="line">	int argc = ZEND_NUM_ARGS();</span><br><span class="line">	int str_len;</span><br><span class="line">	long n;</span><br><span class="line">	if (zend_parse_parameters(argc TSRMLS_CC, &quot;sl&quot;, &amp;str, &amp;str_len, &amp;n) == FAILURE)</span><br><span class="line">		return;</span><br><span class="line">	php_error(E_WARNING, &quot;self_concat: not yet implemented&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些代码是一个到处函数的基本框架了。<br>使用PHPFUNCTION()宏来生成一个适合于Zend引擎的函数原型。其中比较重要的是 zend_parse_parameters 函数，用来获取函数传递的参数；该函数的原型是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">zend_parse_parameters(<span class="keyword">int</span> num_args TSRMLS_DC, <span class="keyword">char</span> *type_spec, …);</span><br></pre></td></tr></table></figure>
<p>第一个参数是参数的个数，通常使用<code>ZEND_NUM_ARGS()</code>的返回值，TSRMLS_DC这个照写就可以了，第三个参数比较复杂是一个表示函数期望的参数类型的字符串，后面紧跟参数值的变量列表，这里有一个PHP的松散变量和动态类型推断到C语言类型的转换。</p>
<p>第三个参数根据一个参数类型对照表生成:</p>
<table>
<thead>
<tr>
<th>类型指定符</th>
<th>对应的C类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>l</td>
<td>long</td>
<td>符号整数</td>
</tr>
<tr>
<td>d</td>
<td>double</td>
<td>浮点数</td>
</tr>
<tr>
<td>s</td>
<td>char *, int</td>
<td>二进制字符串，长度</td>
</tr>
<tr>
<td>b</td>
<td>zend_bool</td>
<td>逻辑型（1或0）</td>
</tr>
<tr>
<td>r</td>
<td>zval *</td>
<td>资源（文件指针，数据库连接等）</td>
</tr>
<tr>
<td>a</td>
<td>zval *</td>
<td>联合数组</td>
</tr>
<tr>
<td>o</td>
<td>zval *</td>
<td>任何类型的对象</td>
</tr>
<tr>
<td>O</td>
<td>zval *</td>
<td>指定类型的对象。需要提供目标对象的类类型</td>
</tr>
<tr>
<td>z</td>
<td>zval *</td>
<td>无任何操作的zval</td>
</tr>
</tbody>
</table>
<p>考虑上面代码的实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (zend_parse_parameters(argc TSRMLS_CC, &quot;sl&quot;, &amp;str, &amp;str_len, &amp;n) == FAILURE)</span><br><span class="line">	return;</span><br></pre></td></tr></table></figure>
<p>“sl”: 第一个字符s代表二进制字符串，它在后面的参数列表中对应两个值，一个 &amp;str， 一个&amp;strlen；第二个字符’l’（L的小写）,表示整数类型参数对应 &amp;n。</p>
<blockquote>
<p>扩展中的字符串都是二进制字符串，即并不以\0作为字符串结束，而是使用一个str_len表示字符串长度，具体看_zval结构体。</p>
</blockquote>
<p>下面的工作就是修改这个函数了。</p>
<h2 id="完成第一个导出函数"><a href="#完成第一个导出函数" class="headerlink" title="完成第一个导出函数"></a>完成第一个导出函数</h2><p>将自动生成的函数更新为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PHP_FUNCTION(self_concat)</span><br><span class="line">&#123;</span><br><span class="line">	char *str = NULL;</span><br><span class="line">	int argc = ZEND_NUM_ARGS();</span><br><span class="line">	int str_len;</span><br><span class="line">	long n;</span><br><span class="line">	char *result; /* Points to resulting string */</span><br><span class="line">	char *ptr; /* Points at the next location we want to copy to */</span><br><span class="line">	int result_length; /* Length of resulting string */</span><br><span class="line">	</span><br><span class="line">	if (zend_parse_parameters(argc TSRMLS_CC, &quot;sl&quot;, &amp;str, &amp;str_len, &amp;n) == FAILURE) &#123;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	result_length = (str_len * n);</span><br><span class="line">	result = (char *) emalloc(result_length + 1);</span><br><span class="line">	ptr = result;</span><br><span class="line">	while (n--) &#123;</span><br><span class="line">		memcpy(ptr, str, str_len);</span><br><span class="line">		ptr += str_len;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	*ptr = &apos;\0&apos;;</span><br><span class="line"></span><br><span class="line">	RETURN_STRINGL(result, result_length, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按照上面的方法，重新编译php， 就可以在php文件中直接使用slef_concat()函数拼接字符串了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">print self_concat(&quot;pop_&quot;, 10);</span><br></pre></td></tr></table></figure>
<p>保存为confirm.php;运行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">php confirm.php</span><br></pre></td></tr></table></figure>
<p>会输出拼接的字符串了。</p>
<h2 id="待续"><a href="#待续" class="headerlink" title="待续"></a>待续</h2>
            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/php-using-late-static-bindings/" itemprop="url">
                  使用后期静态绑定实现MVC的Model的基类
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-08-17T12:34:50+08:00" content="2015-08-17">
              2015-08-17
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Programming/" itemprop="url" rel="index">
                    <span itemprop="name">Programming</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>PHP 5.3中引入了一个后期静态绑定的功能，对于静态绑定都比较熟悉了，就是static修饰的方法或者字段，那这个后期静态绑定又是干什么的呢？</p>
<p>如果在一个类中定义一个静态方法或者静态域成员，如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> $type = <span class="string">'man'</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">echo</span> <span class="string">'run'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以对于静态成员的理解，这些static修饰的成员在所有对象中共享，只有一个实例，可以使用<code>Person::run()</code> 这样的方式直接调用而不需要实例化类。</p>
<h2 id="self调用"><a href="#self调用" class="headerlink" title="self调用"></a>self调用</h2><p>如果在类的内部直接调用这些静态方法，我们一般使用self来指代当前类:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> staic <span class="function"><span class="keyword">function</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">self</span>::run(); <span class="comment">// run before eat...</span></span><br><span class="line">		<span class="comment">// do some eating here</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里使用self来指代当前的类，并用于调用其静态方法。这里，<code>self::</code>和<code>__CLASS__</code> 是一样的，都是<strong>对当前类的静态引用</strong></p>
<h2 id="后期静态绑定"><a href="#后期静态绑定" class="headerlink" title="后期静态绑定"></a>后期静态绑定</h2><p>常用示例代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">who</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="keyword">__CLASS__</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">self</span>::who();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">who</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="keyword">__CLASS__</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B::test();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>后期静态绑定本想通过引入一个新的关键字表示运行时最初调用的类来绕过限制。简单地说，这个关键字能够让你在上述例子中调用 test() 时引用的类是 B 而不是 A。最终决定不引入新的关键字，而是使用已经预留的 static 关键字。</p>
</blockquote>
<p>这里简单的理解就是，B是A的子类，有时候在使用B调用A中实现的的静态方法时，需要使用子类B的一些静态域实现，而不是A实现的静态域。使用<code>self::</code> 调用静态成员只会调用A类的静态成员。这是后应该使用后期静态绑定关键字 <code>static</code>来代替<code>self</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class A &#123;</span><br><span class="line">    public static function who() &#123;</span><br><span class="line">        echo __CLASS__;</span><br><span class="line">    &#125;</span><br><span class="line">    public static function test() &#123;</span><br><span class="line">        static::who(); // 后期静态绑定从这里开始</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A &#123;</span><br><span class="line">    public static function who() &#123;</span><br><span class="line">        echo __CLASS__;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B::test(); // return B</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
<p>好像还是不是很好理解，下面来看这个后静态绑定在MVC框架中的用途，这样更容易理解一些.</p>
<h2 id="使用后期静态绑定实现MVC框架中的model基类"><a href="#使用后期静态绑定实现MVC框架中的model基类" class="headerlink" title="使用后期静态绑定实现MVC框架中的model基类"></a>使用后期静态绑定实现MVC框架中的model基类</h2><p>在一个MVC框架中，通常使用Model来对数据库抽象，把一张数据库表映射到一个Model的子类。比如，一张person表可以对应一个下面的类:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">namespace model</span><br><span class="line"></span><br><span class="line">class Person extends Model &#123;</span><br><span class="line">	public $name;</span><br><span class="line">	public $age;</span><br><span class="line">	</span><br><span class="line">	public function say($words) &#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么有一些通用的数据库操作，我们希望可以放到Model类中实现了，这样在各个Model子类中都可以直接调用，比如 <code>findById()</code> 用来根据id返回一个Person的实例。这个时候有一个问题就是，Model基类中如何知道各个Model子类的表名呢，我们需要子类把表名告知Model基类，这样才能方便些sql语句。</p>
<p>这时候就可以使用后期静态绑定了，因为后期静态绑定可以在子类调用父类的静态方法时将一些静态域使用自己（子类）的静态域。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">findById</span><span class="params">($id)</span> </span>&#123;</span><br><span class="line">		$tableName = <span class="keyword">static</span>::tableName();</span><br><span class="line">		$sql = <span class="string">"select * from &#123;$tableName&#125; where id=&#123;$id&#125; "</span>;</span><br><span class="line">		<span class="comment">// 下面的数据库查询只是一个示例，使用了一个数据库封装</span></span><br><span class="line">		$row = DBConnector::createSql($sql)-&gt;queryOne();</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">static</span>($row);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改进子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">Model</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> functin tableName() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">'person'</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样可以直接使用静态方法获得一个person实例： <code>Person::findById(1);</code> 就可以了。<br>这样其他的model子类也是要在类中实现了静态域 <code>public static function tableName()</code> 就能直接使用Model类中findById方法了。</p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>可以在Model中添加更多的方法来使得数据库操作变得简单，比如 deleteByid(), findByArray() 等等，这非常有用。</p>
<ul>
<li>在非静态环境下，所调用的类即为该对象实例所属的类。由于 $this-&gt; 会在同一作用范围内尝试调用私有方法，而 static:: 则可能给出不同结果。另一个区别是 static:: 只能用于静态属性</li>
<li>后期静态绑定的解析会一直到取得一个完全解析了的静态调用为止。另一方面，如果静态调用使用 parent:: 或者 self:: 将转发调用信息</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span>::who();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">who</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="keyword">__CLASS__</span>.<span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        A::foo();</span><br><span class="line">        <span class="keyword">parent</span>::foo();</span><br><span class="line">        <span class="keyword">self</span>::foo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">who</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="keyword">__CLASS__</span>.<span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">who</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="keyword">__CLASS__</span>.<span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">C::test(); </span><br><span class="line"><span class="comment">// 输出:A C C</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>参考： <a href="http://php.net/manual/zh/language.oop5.late-static-bindings.php" title="http://php.net/manual/zh/language.oop5.late-static-bindings.php" target="_blank" rel="noopener">http://php.net/manual/zh/language.oop5.late-static-bindings.php</a></p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/using-awk/" itemprop="url">
                  使用awk处理文本
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-08-13T12:34:50+08:00" content="2015-08-13">
              2015-08-13
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>在Linux下我们经常需要对一些文本文档做一些处理，尤其像从日志里提取一些数据，这是我们一般会用awk工具和sed工具去实现需求，这里对awk的入门使用简单记录。</p>
<p>awk可以看作一种文本处理工具，一种专注数据操作的编程语言，一个数据处理引擎。其名字来源于三个发明者的姓名首字母。一般在Linux下使用的awk是gawk(gnu awk)。</p>
<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>awk把文本文档看作是数据库，每一行看作一条数据库中的记录，可以指定数据列的分隔符，默认的分隔符是”\t”,即Tab。<br>awk工作流程是这样的：读入有’\n’换行符分割的一条记录，然后将记录按指定的域分隔符划分域，填充域，$0则表示所有域,$1表示第一个域,$n表示第n个域。默认域分隔符是”空白键” 或 “[tab]键”<br>awk的执行模式是： <code>awk &#39;{pattern + action}&#39; {filenames}</code></p>
<p>awk的执行方式：</p>
<p>1.命令行方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">awk [-F  field-separator]  &apos;commands&apos;  input-file(s)</span><br></pre></td></tr></table></figure>
<p>其中，commands 是真正awk命令，[-F域分隔符]是可选的。 input-file(s) 是待处理的文件。<br>在awk中，文件的每一行中，由域分隔符分开的每一项称为一个域。通常，在不指名-F域分隔符的情况下，默认的域分隔符是空格。</p>
<p>2.shell脚本方式<br>将所有的awk命令插入一个文件，并使awk程序可执行，然后awk命令解释器作为脚本的首行，一遍通过键入脚本名称来调用。<br>相当于shell脚本首行的：#!/bin/sh<br>可以换成：#!/bin/awk</p>
<p>3.将所有的awk命令插入一个单独文件，然后调用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">awk -f awk-script-file input-file(s)</span><br></pre></td></tr></table></figure>
<p>其中，-f选项加载awk-script-file中的awk脚本，input-file(s)跟上面的是一样的。</p>
<p>一般是哟你哦个命令行模式就能满足需求了。</p>
<p>这样下面的一行文本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">abc def 123</span><br><span class="line">dfg jik 234</span><br></pre></td></tr></table></figure>
<p>在awk看来就是一个包含三个字段的记录，可以类比到mysql的一行记录，只不过awk没有一个mysql那么强的scheme。<br>这样比如我们要抽出中间的那一行数据，假设文本保存为文件 data.txt</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">awk &apos;&#123;print $2&#125;&apos;</span><br></pre></td></tr></table></figure>
<p>很简单，这样就可以打印出中间的字符def 和jik 了。</p>
<p>下面来一个点点复杂的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Beth	4.00	0</span><br><span class="line">Dan	3.75	0</span><br><span class="line">kathy	4.00	10</span><br><span class="line">Mark	5.00	20</span><br><span class="line">Mary	5.50	22</span><br><span class="line">Susie	4.25	18</span><br></pre></td></tr></table></figure>
<p>对于这样的数据<br>使用 <code>awk &#39;$3&gt;0 { print $, $2 * $3 }&#39; data.txt</code> 这样会输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Kathy 40</span><br><span class="line">Mark 100</span><br><span class="line">Mary 121</span><br><span class="line">Susie 76.5</span><br></pre></td></tr></table></figure>
<p>理解就是可以在{}前面添加一个判断的语句，只有符合条件的行才会执行后面的语句。</p>
<h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><p>相对于print输出，可以使用printf进行格式化输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">awk  -F &apos;:&apos;  &apos;&#123;printf(&quot;filename:%10s,linenumber:%s,columns:%s,linecontent:%s\n&quot;,FILENAME,NR,NF,$0)&#125;&apos; /etc/passwd</span><br></pre></td></tr></table></figure>
<p>print函数的参数可以是变量、数值或者字符串。字符串必须用双引号引用，参数用逗号分隔。如果没有逗号，参数就串联在一起而无法区分。这里，逗号的作用与输出文件的分隔符的作用是一样的，只是后者是空格而已。</p>
<p>printf函数，其用法和c语言中printf基本相似,可以格式化字符串,输出复杂时，printf更加好用，代码更易懂。</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/remove-last-letter-of-each-line/" itemprop="url">
                  使用后期静态绑定实现MVC的Model的基类
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-08-11T12:34:50+08:00" content="2015-08-11">
              2015-08-11
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/framework/" itemprop="url" rel="index">
                    <span itemprop="name">framework</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>一直拖着没写，估计不会写了</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/php-using-spl-autoloader/" itemprop="url">
                  PHP中自动加载的几种实现
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-08-11T12:34:50+08:00" content="2015-08-11">
              2015-08-11
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Programming/" itemprop="url" rel="index">
                    <span itemprop="name">Programming</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>PHP自动加载是一个很有用的技巧，我们应该在项目中尽量使用autoload来减少维护类加载的工作。 </p>
<h2 id="使用-autoload"><a href="#使用-autoload" class="headerlink" title="使用__autoload"></a>使用__autoload</h2><p>在使用PHP的项目中，如何实现自动加载对于新人总是一个很疑惑的问题，一般写过的一些PHP，或者用过一些框架的同学都知道通过实现__autoload()函数来实现简单的自动加载：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function __autoload($classname) &#123;</span><br><span class="line">    $filename = &quot;./&quot;. $classname .&quot;.php&quot;;</span><br><span class="line">    include_once($filename);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过这样的方式缺点也能明显就是只能定义一种加载策略，或者把这个函数实现的很复杂来实现多样的自动加载策略。</p>
<h2 id="使用spl-autoload-register"><a href="#使用spl-autoload-register" class="headerlink" title="使用spl_autoload_register"></a>使用spl_autoload_register</h2><p>现在推荐使用的是<code>spl_autoload_register()</code>来注册自动加载器，它可以用来注册多个自动加载策略。它的函数签名是:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool spl_autoload_register ([ callable $autoload_function [, bool $throw = true [, bool $prepend = false ]]] )</span><br></pre></td></tr></table></figure>
<p>一般来说，我们只关注第一个参数，他是一个callable类型的function，一般简单的传入一个函数名称的字符串，也可以传入类名和方法名的数组，也可以传入一个匿名函数（PHP 5.3之后）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function my_autoloader($class) &#123;</span><br><span class="line">    include &apos;classes/&apos; . $class . &apos;.class.php&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">spl_autoload_register(&apos;my_autoloader&apos;);</span><br><span class="line"></span><br><span class="line">// Or, using an anonymous function as of PHP 5.3.0</span><br><span class="line">spl_autoload_register(function ($class) &#123;</span><br><span class="line">    include &apos;classes/&apos; . $class . &apos;.class.php&apos;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在PHP 5.3 引入命名空间后，我们还可以使用<a href="http://php.net/manual/en/function.spl-autoload-register.php#92514" target="_blank" rel="noopener">一种更方便的自动加载策略</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spl_autoload_extensions(&quot;.php&quot;); // comma-separated list</span><br><span class="line">spl_autoload_register();</span><br><span class="line"></span><br><span class="line">// 等价于</span><br><span class="line">function my_autoload ($pClassName) &#123;</span><br><span class="line">    include(__DIR__ . &quot;/&quot; . $pClassName . &quot;.php&quot;);</span><br><span class="line">&#125;</span><br><span class="line">spl_autoload_register(&quot;my_autoload&quot;);</span><br></pre></td></tr></table></figure>
<p>据说第一种可以效率更高。</p>
<h2 id="使用SplClassLoader"><a href="#使用SplClassLoader" class="headerlink" title="使用SplClassLoader"></a>使用SplClassLoader</h2><p>SplClassLoader是Jonathan H. Wage，Roman S. Borschel等人开发的一个用于PHP 5.3根据命名空间和类名实现自动加载的类。使用比较方便，这里推荐使用。其实现并不复杂使用一个类，源码如下（去掉了注释）:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class SplClassLoader</span><br><span class="line">&#123;</span><br><span class="line">    private $_fileExtension = &apos;.php&apos;;</span><br><span class="line">    private $_namespace;</span><br><span class="line">    private $_includePath;</span><br><span class="line">    private $_namespaceSeparator = &apos;\\&apos;;</span><br><span class="line"></span><br><span class="line">    public function __construct($ns = null, $includePath = null) &#123;</span><br><span class="line">        $this-&gt;_namespace = $ns;</span><br><span class="line">        $this-&gt;_includePath = $includePath;</span><br><span class="line">    &#125;</span><br><span class="line">    public function setNamespaceSeparator($sep) &#123;</span><br><span class="line">        $this-&gt;_namespaceSeparator = $sep;</span><br><span class="line">    &#125;</span><br><span class="line">    public function getNamespaceSeparator() &#123;</span><br><span class="line">        return $this-&gt;_namespaceSeparator;</span><br><span class="line">    &#125;</span><br><span class="line">    public function setIncludePath($includePath) &#123;</span><br><span class="line">        $this-&gt;_includePath = $includePath;</span><br><span class="line">    &#125;</span><br><span class="line">    public function getIncludePath() &#123;</span><br><span class="line">        return $this-&gt;_includePath;</span><br><span class="line">    &#125;</span><br><span class="line">    public function setFileExtension($fileExtension) &#123;</span><br><span class="line">        $this-&gt;_fileExtension = $fileExtension;</span><br><span class="line">    &#125;</span><br><span class="line">    public function getFileExtension() &#123;</span><br><span class="line">        return $this-&gt;_fileExtension;</span><br><span class="line">    &#125;</span><br><span class="line">    public function register() &#123;</span><br><span class="line">        spl_autoload_register(array($this, &apos;loadClass&apos;));</span><br><span class="line">    &#125;</span><br><span class="line">    public function unregister() &#123;</span><br><span class="line">        spl_autoload_unregister(array($this, &apos;loadClass&apos;));</span><br><span class="line">    &#125;</span><br><span class="line">    public function loadClass($className) &#123;</span><br><span class="line">        if (null === $this-&gt;_namespace || $this-&gt;_namespace.$this-&gt;_namespaceSeparator === substr($className, 0, strlen($this-&gt;_namespace.$this-&gt;_namespaceSeparator))) &#123;</span><br><span class="line">            $fileName = &apos;&apos;;</span><br><span class="line">            $namespace = &apos;&apos;;</span><br><span class="line">            if (false !== ($lastNsPos = strripos($className, $this-&gt;_namespaceSeparator))) &#123;</span><br><span class="line">                $namespace = substr($className, 0, $lastNsPos);</span><br><span class="line">                $className = substr($className, $lastNsPos + 1);</span><br><span class="line">                $fileName = str_replace($this-&gt;_namespaceSeparator, DIRECTORY_SEPARATOR, $namespace) . DIRECTORY_SEPARATOR;</span><br><span class="line">            &#125;</span><br><span class="line">            $fileName .= str_replace(&apos;_&apos;, DIRECTORY_SEPARATOR, $className) . $this-&gt;_fileExtension;</span><br><span class="line"></span><br><span class="line">            // @add wuxu 验证文件是否存在，要不可能会抛出异常</span><br><span class="line">            $fileName = ($this-&gt;_includePath !== null ? $this-&gt;_includePath . DIRECTORY_SEPARATOR : &apos;&apos;) . $fileName;</span><br><span class="line"></span><br><span class="line">            if (file_exists($fileName)) require $fileName;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整的代码见 <a href="https://gist.github.com/jwage/221634" title="https://gist.github.com/jwage/221634" target="_blank" rel="noopener">GitHub Gist</a>。<br>（还有一些在此基础上的修改版本，比如：<a href="https://gist.github.com/jwage/221634）" target="_blank" rel="noopener">https://gist.github.com/jwage/221634）</a></p>
<p>它的使用方式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Example which loads classes for the Doctrine Common package in the</span><br><span class="line">// Doctrine\Common namespace.</span><br><span class="line">$classLoader = new SplClassLoader(&apos;Doctrine\Common&apos;, &apos;/path/to/doctrine&apos;);</span><br><span class="line">$classLoader-&gt;register();</span><br></pre></td></tr></table></figure>
<p>这是一个实现使用命名空间的PHP项目的自动加载的方式（PSR-0），使用上面的注册代码，可以注册一个Doctrine\Common的namespace，它对应的根目录是/path/to/doctrine。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这样对于实现一个使用命名空间的项目非常重要。<br>接下来会写一篇如何在一个项目中使用namespace（PSR-0）来使项目的结构更加科学。</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/php-variable-implementation/" itemprop="url">
                  PHP变量在内核中的实现
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-08-10T12:34:50+08:00" content="2015-08-10">
              2015-08-10
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Programming/" itemprop="url" rel="index">
                    <span itemprop="name">Programming</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>PHP本身是一种弱类型的语言，可以在程序中改变变量存储的值的类型。那么这些变量在PHP的底层是如何实现的呢，理解内核变中变量的实现机制将有利于我们理解PHP的变量系统。</p>
<h2 id="变量的类型"><a href="#变量的类型" class="headerlink" title="变量的类型"></a>变量的类型</h2><p>对PHP有一定理解的同学应该都已经知道了PHP在内核中是使用zval这个结构体来存储变量的，也就是说不同的变量在底层都是一个zval结构体，它定义在Zend/zend.h中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct _zval_struct &#123;</span><br><span class="line">    zvalue_value value; /* 变量的值 */</span><br><span class="line">    zend_uint refcount__gc;</span><br><span class="line">    zend_uchar type;    /* 变量当前的数据类型 */</span><br><span class="line">    zend_uchar is_ref__gc;</span><br><span class="line">&#125;;</span><br><span class="line">typedef struct _zval_struct zval;</span><br><span class="line"></span><br><span class="line">//在Zend/zend_types.h里定义的：</span><br><span class="line">typedef unsigned int zend_uint;</span><br><span class="line">typedef unsigned char zend_uchar;</span><br></pre></td></tr></table></figure>
<p>其中保存变量的值的value则是zvalue_value类型，它是一个union：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef union _zvalue_value &#123;</span><br><span class="line">    long lval;  /* long value */</span><br><span class="line">    double dval;    /* double value */</span><br><span class="line">    struct &#123;</span><br><span class="line">        char *val;</span><br><span class="line">        int len;</span><br><span class="line">    &#125; str;</span><br><span class="line">    HashTable *ht;  /* hash table value */</span><br><span class="line">    zend_object_value obj;</span><br><span class="line">&#125; zvalue_value;</span><br></pre></td></tr></table></figure>
<p>PHP使用zvalue_value实现8种数据类型，这些类型在内核中分别对应特定的常量。通过这个union可以理解常用的类型判断函数： <code>is_null, is_bool, is_long, is_double, is_string, is_array, is_object, is_resource</code> 他们的效率应该是很高的。同时也可以猜想gettype函数的实现大概使用了Z_TYPE_P宏，这个宏大概和zval结构的type有关<br>在Zend/zend_operators.h中定义的宏：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define Z_TYPE(zval)        (zval).type</span><br><span class="line">#define Z_TYPE_P(zval_p)    Z_TYPE(*zval_p)</span><br><span class="line">#define Z_TYPE_PP(zval_pp)  Z_TYPE(**zval_pp)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，虽然在32位系统中，signed long的存储范围是-2147483648～2147483647 的整数，但是要注意，如果整数变量超出了这个范围并不会直接溢出，而是会转换程double类型继续计算。</p>
</blockquote>
<p>PHP内核还同时在zval结构里保存着字符串的实际长度， 这个设计使PHP可以在字符串中嵌入‘\0’字符，也使PHP的字符串是二进制安全的， 可以安全的存储二进制数据</p>
<h2 id="变量的值"><a href="#变量的值" class="headerlink" title="变量的值"></a>变量的值</h2><p>string型变量比较特殊，因为内核在保存String型变量时，不仅保存了字符串的值，还保存了它的长度， 所以它有对应的两种宏组合STRVAL和STRLEN，即：Z_STRVAL、Z_STRVAL_P、Z_STRVAL_PP与Z_STRLEN、Z_STRLEN_P、Z_STRLEN_PP。 前一种宏返回的是char *型，即字符串的地址；后一种返回的是int型，即字符串的长度。</p>
<p>Array型变量的值其实是存储在C语言实现的HashTable中的， 我们可以用ARRVAL组合宏（Z_ARRVAL, Z_ARRVAL_P, Z_ARRVAL_PP）这三个宏来访问数组的值。</p>
<p>对象是一个复杂的结构体（zend_object_value结构体），不仅存储属性的定义、属性的值，还存储着访问权限、方法等信息。 内核中定义了以下组合宏让我们方便的操作对象： OBJ_HANDLE：返回handle标识符， OBJ_HT：handle表， OBJCE：类定义， OBJPROP：HashTable的属性， OBJ_HANDLER：在OBJ_HT中操作一个特殊的handler方法。</p>
<p>资源型变量的值其实就是一个整数，可以用RESVAL组合宏来访问它，我们把它的值传给zend_fetch_resource函数，便可以得到这个资源的操作句柄，如mysql的链接句柄等。</p>
<h2 id="创建PHP变量"><a href="#创建PHP变量" class="headerlink" title="创建PHP变量"></a>创建PHP变量</h2><p>在内核中是如何创建zval的呢，PHP内核中提供了一个MAKE_STD_ZVAL(pzv)宏，它使用内核的方式类申请一块内存，并将其地址赋给pzv。这个宏能自动处理内存不足的问题。<br>获取空间后，就可以给这个zval赋值了。旧的做法是先确定zval的类型：<code>Z_TYPE_P(pzv)=ISNULL</code> 来设置其为null类型，再通过Z_SOMEVAL_P的宏类赋值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Z_TYPE_P(pzv)=IS_BOOL;</span><br><span class="line">Z_BVAL(PZV)=1;</span><br></pre></td></tr></table></figure>
<p>不过现在PHP内核提供了更多的宏可以更方便的操作zval的值。</p>
<p>新宏    其它宏的实现方法</p>
<ul>
<li>ZVAL_NULL(pvz); <strong>(注意这个Z和VAL之间没有下划线！)</strong>    <code>Z_TYPE_P(pzv) = IS_NULL;</code><strong>(IS_NULL型不用赋值，因为这个类型只有一个值就是null)</strong></li>
<li>ZVAL_BOOL(pzv, b); <strong>(将pzv所指的zval设置为IS_BOOL类型，值是b)</strong>    <code>Z_TYPE_P(pzv) = IS_BOOL; Z_BVAL_P(pzv) = b ? 1 : 0;</code></li>
<li>ZVAL_TRUE(pzv); <strong>(将pzv所指的zval设置为IS_BOOL类型，值是true)</strong>    ZVAL_BOOL(pzv, 1);</li>
<li>ZVAL_FALSE(pzv); <strong>(将pzv所指的zval设置为IS_BOOL类型，值是false)</strong>    ZVAL_BOOL(pzv, 0);</li>
<li>ZVAL_LONG(pzv, l); <strong>(将pzv所指的zval设置为IS_LONG类型，值是l)</strong>    <code>Z_TYPE_P(pzv) = IS_LONG;Z_LVAL_P(pzv) = l;</code></li>
<li>ZVAL_DOUBLE(pzv, d); <strong>(将pzv所指的zval设置为IS_DOUBLE类型，值是d)</strong>    <code>Z_TYPE_P(pzv) = IS_DOUBLE; Z_DVAL_P(pzv) = d;</code></li>
<li>ZVAL_STRINGL(pzv,str,len,dup);<strong>(下面单独解释)</strong>    <code>Z_TYPE_P(pzv) = IS_STRING;Z_STRLEN_P(pzv) = len;if (dup) {Z_STRVAL_P(pzv) =estrndup(str, len + 1);} else {Z_STRVAL_P(pzv) = str;}</code></li>
<li>ZVAL_STRING(pzv, str, dup);    <code>ZVAL_STRINGL(pzv, str,strlen(str), dup);</code></li>
<li>ZVAL_RESOURCE(pzv, res);    <code>Z_TYPE_P(pzv) = IS_RESOURCE;</code></li>
<li>Z_RESVAL_P(pzv) = res;</li>
</ul>
<h2 id="变量的存储方式"><a href="#变量的存储方式" class="headerlink" title="变量的存储方式"></a>变量的存储方式</h2><p>用户在PHP中定义的变量可以在一个HashTable中找到，当PHP中定义了一个变量，内核会自动把它的信息存储到一个用HashTable实现的符号表里。<br>全局作用域的符号表在调用扩展的RINIT方法前创建，并且在RSHUTDOWN方法执行之后自动销毁。</p>
<p>一个例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$foo = &apos;bar&apos;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
<p>上面是一段PHP语言的例子，我们创建了一个变量，并把它的值设置为’bar’，在以后的代码中我们便可以使用$foo变量。相同的功能我们怎样在内核中实现呢？我们可以先构思一下步骤：</p>
<ul>
<li>创建一个zval结构，并设置其类型。</li>
<li>设置值为’bar’。</li>
<li>将其加入当前作用域的符号表，只有这样用户才能在PHP里使用这个变量。</li>
</ul>
<p>具体的代码为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    zval *fooval;</span><br><span class="line"></span><br><span class="line">    MAKE_STD_ZVAL(fooval);</span><br><span class="line">    ZVAL_STRING(fooval, &quot;bar&quot;, 1);</span><br><span class="line">    ZEND_SET_SYMBOL( EG(active_symbol_table) ,  &quot;foo&quot; , fooval);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，我们声明一个zval指针，并申请一块内存。然后通过ZVAL_STRING宏将值设置为‘bar’,最后一行的作用就是将这个zval加入到当前的符号表里去，并将其label定义成foo，这样用户就可以在代码里通过$foo来使用它了。</p>
<h2 id="变量的检索"><a href="#变量的检索" class="headerlink" title="变量的检索"></a>变量的检索</h2><p>在PHP中定义的变量，在内核中通过zend_hash_find()函数来找到当前作用域下用户定义好的变量。zend_hash_find是内核提供的操作hashTable的API之一。<br><a href="http://www.walu.cc/phpbook/2.5.md" title="http://www.walu.cc/phpbook/2.5.md" target="_blank" rel="noopener">http://www.walu.cc/phpbook/2.5.md</a></p>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>我们可以通过符号表获取用户在PHP中定义的变量了，想想一下在PHP中的自动类型转换，它在底层C中是怎么实现的呢。<br>内核中提供了很多函数专门来帮助实现类型转换，这类函数统一的形式为： <code>convert_to_*()</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//将任意类型的zval转换成字符串</span><br><span class="line">void change_zval_to_string(zval *value)</span><br><span class="line">&#123;</span><br><span class="line">    convert_to_string(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//其它基本的类型转换函数</span><br><span class="line">ZEND_API void convert_to_long(zval *op);</span><br><span class="line">ZEND_API void convert_to_double(zval *op);</span><br><span class="line">ZEND_API void convert_to_null(zval *op);</span><br><span class="line">ZEND_API void convert_to_boolean(zval *op);</span><br><span class="line">ZEND_API void convert_to_array(zval *op);</span><br><span class="line">ZEND_API void convert_to_object(zval *op);</span><br><span class="line"></span><br><span class="line">ZEND_API void _convert_to_string(zval *op ZEND_FILE_LINE_DC);</span><br><span class="line">#define convert_to_string(op) if ((op)-&gt;type != IS_STRING) &#123; _convert_to_string((op) ZEND_FILE_LINE_CC); &#125;</span><br></pre></td></tr></table></figure>
<p>其中，convert_to_string其实是一个宏函数，调用的另外一个函数；另外没有convert_to_resource()的转换函数，因为资源的值在用户层面上，根本就没有意义，内核不会对它的值(不是指那个数字)进行转换。</p>
<p>参考： <a href="http://www.walu.cc/phpbook/2.md" title="http://www.walu.cc/phpbook/2.md" target="_blank" rel="noopener">PHP变量在内核中的实现</a></p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/nsq-basic/" itemprop="url">
                  nsq实时消息服务的TCP协议规范
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-07-28T12:34:50+08:00" content="2015-07-28">
              2015-07-28
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/tools/" itemprop="url" rel="index">
                    <span itemprop="name">tools</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>NSQ是使用golang开发的实时分布式消息处理平台，由bit.ly开源的项目，可以用来处理每天十亿级别的消息。</p>
<p>由于nsq可以直接编译为可执行的二进制文件的特性，nsq的安装非常简单，下载二进制包解压就可以运行了。 参考<a href="http://nsq.io/deployment/installing.html" title="http://nsq.io/deployment/installing.html" target="_blank" rel="noopener">官方文档</a></p>
<p>快速运行也很简单依次在终端中启动nsq的服务即可。这里也不细说了，参考： <a href="http://nsq.io/overview/quick_start.html" target="_blank" rel="noopener">http://nsq.io/overview/quick_start.html</a></p>
<p>关于nsq的几个组件会在后面记一篇，现在主要学习一些nsq中使用的TCP协议规范。</p>
<blockquote>
<p>NSQ的协议足够简单，任何语言编译客户端都很容易。</p>
</blockquote>
<p><strong>nsqd进程通过监听配置的TCP端口来接受客户端连接</strong></p>
<p><strong>对nsq的用途理解有点错误了</strong></p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/litle-known-css-facts/" itemprop="url">
                  那些你可能不知道但是很有意思的CSS Tricks
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-07-27T12:34:50+08:00" content="2015-07-27">
              2015-07-27
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/fe/" itemprop="url" rel="index">
                    <span itemprop="name">fe</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>在去年的时候，Louis Lazaris在sitepoint上发了一篇文章 [http</p>
<p>参考：<br><a href="http://www.sitepoint.com/12-little-known-css-facts/" target="_blank" rel="noopener">12 Little-Known CSS Facts</a><br><a href="http://www.sitepoint.com/12-little-known-css-facts-the-sequel/" target="_blank" rel="noopener">12 Little-Known CSS Facts (The Sequel)</a></p>
<p>CSS 本身并不是非常复杂的语言，但是即使你写过很多的CSS样式，你总会感觉到对它并不了解，使用了很多年之后你还是会偶遇很多你没有用过的“有意思”的样式属性，本文作者列举了一些这样的Tricks。</p>
<h2 id="color属性不只是作用域文本"><a href="#color属性不只是作用域文本" class="headerlink" title="color属性不只是作用域文本"></a>color属性不只是作用域文本</h2><p>color属性大家都很熟悉，一般用来设置文本(Text)的颜色属性，但是如果你把body标签的color设置为某种颜色，比如<code>color: yellow</code>几乎所有的东西就都会变成黄色的，包括图片的替代文本，列表的bullet，border等，但是<code>hr</code>标签并不会默认继承这个颜色，需要手动设置 <code>border-color: inherit</code>才会变成黄色。<br>color属性的spec中是这么定义的：</p>
<blockquote>
<p>This property describes the foreground color of an element’s text<br>content. In addition it is used to provide a potential indirect value<br>… for any other properties that accept color values.</p>
</blockquote>
<h2 id="visibility属性可以设置为”collapse”"><a href="#visibility属性可以设置为”collapse”" class="headerlink" title="visibility属性可以设置为”collapse”"></a>visibility属性可以设置为”collapse”</h2><p>所有元素的visibility属性的默认值都是<code>visible</code>, 我们可以把它设置为<code>hidden</code>来隐藏一个元素，与<code>dispaly: none</code>表现不同的是，hidden的元素仍然会占据原来的空间（still occupy space）<br>visibility属性还有一个值就是<code>collapse</code>，它的表现一般和<code>hidden</code>是一样的，但是在table中表现会不一样，可能你已经想到了，在table元素中的行，行组，列，列组中使用<code>collapse</code>属性它的表现和<code>display:none</code>是一样的。<br><strong>不过用于浏览器对这个属性的表现并不一致，所以还是<a href="http://css-tricks.com/almanac/properties/v/visibility/" target="_blank" rel="noopener">不要使用</a>了</strong></p>
<h2 id="background属性有了新的内容"><a href="#background属性有了新的内容" class="headerlink" title="background属性有了新的内容"></a>background属性有了新的内容</h2><p>在CSS 2.1中，background属性有color, image, repeat, attachment, position 5个“子内容”，在CSS3 中，添加很了一些新内容：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">background</span>: <span class="selector-attr">[background-color]</span> <span class="selector-attr">[background-image]</span> <span class="selector-attr">[background-repeat]</span></span><br><span class="line">            [background-attachment] [background-position] / [ background-size]</span><br><span class="line">            <span class="selector-attr">[background-origin]</span> <span class="selector-attr">[background-clip]</span></span><br></pre></td></tr></table></figure>
<p>一个示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.example &#123;</span><br><span class="line">  background: aquamarine url(img.png)</span><br><span class="line">	no-repeat</span><br><span class="line">	scroll</span><br><span class="line">	center center / 50%</span><br><span class="line">	content-box content-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些新属性在所有现代浏览器都能正常工作，只不过好像用处也不大。</p>
<h2 id="clip属性只在绝对定位元素上起作用"><a href="#clip属性只在绝对定位元素上起作用" class="headerlink" title="clip属性只在绝对定位元素上起作用"></a>clip属性只在绝对定位元素上起作用</h2><p>clip属性可以用来对元素进行裁剪，它的值是一个图形，比如rect，或者是auto。<br>但是要注意，clip属性只对决定定位元素起作用，包括<code>position: absolute;</code>,和<code>position: fixed</code>两种情况。<br>使用:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.example</span> &#123;</span><br><span class="line">	<span class="attribute">position</span>: absolute;</span><br><span class="line">	<span class="attribute">clip</span>: <span class="built_in">rect</span>(110px, 160px, 170px, 60px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它的表现可以参考这张图片: <img src="http://cdn.impressivewebs.com/2012-05/clip-visual.jpg" alt=""><br>更多关于clip的内容，可以查看<a href="http://www.impressivewebs.com/css-clip-property/" target="_blank" rel="noopener">这里</a></p>
<h2 id="垂直百分比和容器的宽度有关而不是高度"><a href="#垂直百分比和容器的宽度有关而不是高度" class="headerlink" title="垂直百分比和容器的宽度有关而不是高度"></a>垂直百分比和容器的宽度有关而不是高度</h2><p>这个听起来有点奇怪，我们知道百分比计算宽度是基于容器的宽度的，但是实际上padding-top, margin-top, padding-bottom, margin-bottom这些属性的百分比属性也是基于容器的宽度的，而不是高度。<br>这是挺有意思的。</p>
<h2 id="border属性-is-Kind-of-Like-Inception"><a href="#border属性-is-Kind-of-Like-Inception" class="headerlink" title="border属性 is Kind of Like Inception"></a>border属性 is Kind of Like Inception</h2><p>border属性我们会经常使用，比如这样子：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.somecontainer</span> &#123;</span><br><span class="line">	<span class="attribute">border</span>: solid <span class="number">1px</span> black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们知道border属性是border-style, border=width, border-color三个属性的综合声明。但是其实这三个属性都可以对上下左右四条边分别设置属性：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.somecontainer</span> &#123;</span><br><span class="line">	<span class="attribute">border-width</span>: <span class="number">2px</span> <span class="number">5px</span> <span class="number">1px</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样可以把border设置的很复杂，不过在实际使用中，并不要这么用，因为这样使得整个元素显得混乱而导致页面风格混乱。</p>
<h2 id="text-decoration-现在也成为了一种速记符（shorthand）"><a href="#text-decoration-现在也成为了一种速记符（shorthand）" class="headerlink" title="text-decoration 现在也成为了一种速记符（shorthand）"></a>text-decoration 现在也成为了一种速记符（shorthand）</h2><p>新的css规范中，可以这样使用text-decoration属性：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">	<span class="attribute">text-decoration</span>: overline aqua wavy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个值是<code>text-decoration-line</code>, 第二个是<code>text-decoration-color</code>, 第三个是 <code>text-dcoration-style</code>属性<br>不过这个属性只在firefox中实现了。</p>
<h2 id="border-width属性可以接受关键字值"><a href="#border-width属性可以接受关键字值" class="headerlink" title="border-width属性可以接受关键字值"></a>border-width属性可以接受关键字值</h2><p>现在border-width 可以接受 <code>medium</code>, <code>thin</code>, <code>thick</code>关键字了。他们在浏览器实现中大概是1px, 2px, 5px;不过在spec中并没有指定他们具体的值。</p>
<h2 id="几乎没人使用botder-image"><a href="#几乎没人使用botder-image" class="headerlink" title="几乎没人使用botder-image"></a>几乎没人使用botder-image</h2><p><code>border-image</code>看起来是个不错的属性，使某些表现变得整洁，有一个特别经典的例子是在一圈文字的border加一圈花or狗爪印？不过在现实中几乎没有人会使用这个属性，我也没有使用过。。</p>
<h2 id="empty-cells属性"><a href="#empty-cells属性" class="headerlink" title="empty-cells属性"></a>empty-cells属性</h2><p>这个属性被所有主流浏览器支持，包括IE8。它的用法如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">table</span> &#123;</span><br><span class="line">	<span class="attribute">empty-cell</span>: hide;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个属性用于table元素中空td的样式。或许会有用哦。 测试： <a href="http://codepen.io/SitePoint/pen/yfhtq" target="_blank" rel="noopener">codepen</a></p>
<h2 id="font-style属性接受“oblique”值"><a href="#font-style属性接受“oblique”值" class="headerlink" title="font-style属性接受“oblique”值"></a>font-style属性接受“oblique”值</h2><p>这个看起来和 <code>font-style: italic</code> 并没有什么区别，都是斜体字体，spec中是这么描述的：</p>
<blockquote>
<p>“…selects a font that is labeled as an oblique face, or an italic face if one is not.”</p>
</blockquote>
<p>如果设置的字体没有真正的italic样式（face），那么<code>font-style:italic</code> 和 <code>font-style: oblique</code>的表现是一样的。</p>
<h2 id="word-wrap-属性和overflow-wrap属性是一样的"><a href="#word-wrap-属性和overflow-wrap属性是一样的" class="headerlink" title="word-wrap 属性和overflow-wrap属性是一样的"></a>word-wrap 属性和overflow-wrap属性是一样的</h2><p><code>word-wrap</code>是微软提出的一个属性，所以在IE老版本中都有很好的支持，但是W3C决定使用<code>overflow-wrap</code> 替换掉 <code>word-wrap</code>。但是现在所有的浏览器都支持 <code>word-wrap</code>属性了，所以要替换也不是那么容易的事了。</p>
<p>没什么问题的话还是继续使用<code>word-wrap</code>吧。</p>
<h2 id="待续"><a href="#待续" class="headerlink" title="待续"></a>待续</h2>
            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    

  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/15/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><span class="page-number current">16</span><a class="page-number" href="/page/17/">17</a><a class="page-number" href="/page/18/">18</a><a class="extend next" rel="next" href="/page/17/"><i class="fa fa-angle-right"></i></a>
  </nav>



        </div>

        


        

      </div>

      
        
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="/images/avatar.jpg" alt="wuxu" itemprop="image"/>
          <p class="site-author-name" itemprop="name">wuxu</p>
        </div>
        <p class="site-description motion-element" itemprop="description">Wu Xu的个人博客</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">176</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">24</span>
              <span class="site-state-item-name">分类</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">147</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/wuxu92" target="_blank">
                  
                    <i class="fa fa-github"></i> GitHub
                  
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/wuxu92" target="_blank">
                  
                    <i class="fa fa-twitter"></i> Twitter
                  
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/kiwidock" target="_blank">
                  
                    <i class="fa fa-weibo"></i> Weibo
                  
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://douban.com/people/wuxu92" target="_blank">
                  
                    <i class="fa fa-douban"></i> Douban
                  
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.zhihu.com/people/wuxu92" target="_blank">
                  
                    <i class="fa fa-zhihu"></i> Zhihu
                  
                </a>
              </span>
            
          
        </div>

        
        
          <div class="cc-license motion-element" itemprop="license">
            <a href="http://creativecommons.org/licenses/by-nc-sa/4.0" class="cc-opacity" target="_blank">
              <img src="/images/cc-by-nc-sa.svg" alt="Creative Commons" />
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


      
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2014 - 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="icon-next-heart fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wuxu</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  

  
    
    

  


  

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.2"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.2"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
<script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

<script type="text/javascript" src="/js/motion.js?v=0.4.5.2" id="motion.global"></script>


  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  

  <script type="text/javascript" src="/js/bootstrap.js"></script>

  
  

  
  

</body>
</html>
