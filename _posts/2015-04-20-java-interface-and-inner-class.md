# 接口与内部类 #
这一部分包含下面的内容：

1. 接口
2. 内部类
3. 对象克隆
4. 代理
5. 接口与回调

接口技术主要用来买描述居右什么功能，而并不实现他们，一个类可以实现一个或者多个接口。这是面向对象性的基础之一。
内部内是定义在另外一个类的内部，其中的方法可以访问包含他们的外部类的域，内部类主要用来设计具有相互协作关系的类的集合。

## 接口 ##
> 如果类遵从某个特定接口，那么就履行这项服务。

直观地，接口中的所有方法都是自动地属于public，因此，在接口声明中方法时，不需要提供关键字public。当然接口本身是需要权限修饰符关键字的。一个常用的定义类似于：

```java
public interface SomeAble<T> {
	int someFunction(T t); // do not add {} here
}

class someClass implements SomeAble { 
	public int someFunction(Type t) {
		... // implements
	}
 }
```

虽然接口中定义的方法不需要public修饰，但是在具体类中实现时需要加上public修饰，否则编译器认为这个方法的访问属性是包可见性。

> 你当然不能使用new去实例化一个接口，但是可以声明接口的变量，我们经常这么做。
> 接口也是可以继承的，虽然在接口中不能提供实例域或者静态方法，但是**可以**包含常量。且它们自动是public的

```java 
public interface A extends BAble {
	double PI=3.14;
}
```
### 对象克隆 ###
变量拷贝是一个经常需要考虑的操作。直接拷贝一个变量时，由于一切都是对象，实际上两个变量都是引用同一个对象。这样改变一个变量所引用的对象将会对另一个变量产生影响。
如果需要他们从此各自改变自己的状态，需要使用clone方法。clone中需要考虑，对象中包含了自对象的引用时，拷贝的结果似乎不太符合我们的需求。这种叫做“浅克隆”，我们要实现一个“深克隆”，一个从头到尾的新对象。

> 一个有意思的事情是：对于克隆,我们一般要实现Cloneable这个接口，但是实际上Cloneable这个接口并没有定义任何方法，clone这个方法是来自Object类(protected)的,我们需要使用public修饰符重写这个方法。
> Cloneable接口的作用只是做一个标记，当对一个没有实现Cloneable接口的对象克隆时，会产生一个已检验异常（checked exception），标记接口的作用就是可以使用instanceof进行类型检查

关于是否需要实现clone方法有不同的看法，很多人认为应该完全避免使用clone方法，这样并没有什么不妥，毕竟clone方确实有些笨拙。幸好，克隆的应用比想象的要少很多，（也许只有在笔试中比较常用～），标准类库中大约只有5%的类实现了clone方法。


### 接口与回调 ###
在很多的语言中，比如JavaScript，回调可以直接提供一个函数名，回调自动执行这个函数，但是Java标准类库中的类采用的是面向对象方法。将某个类的对象传递给定时器，然后定时器去调用这个对象的方法。

> 虽然Java也有函数指针的对应物：Method对象，但是它难用而且慢速，并且不能在编译器提供类型的安全性检查。so～一般不要用

参与回调的类需要实现java.awt.event包中的ActionListener接口。实现接口的actionPerformed方法。

```java
class T implements ActionListener {
	public void actionPerformed(ActionEvent event) {
		do something here
	}
}

ActionListener listener = new T();
javax.swing.Timer t = new Timer(1000, listener);
t.start();
```

## 内部类 ##
内部类是定义在一个类中的类。它有以下性质：
- 内部类的方法可以访问定义所在的作用域中（包括外围类的数据域）的数据，**包括私有域**
- 内部内可以对同一个包中的其他类应藏起来
- 当想要定义一个回调函数且不想编写大量代码时，使用**匿名内部类**非常便捷

内部类拥有一个对外围类的引用，这个引用在内部类的定义中是不可见的，编译器会修改所有内部类的构造器，添加一个外围类引用的参数。

内部类的特殊语法：
事实上，使用外围类引用的正规语法比较复杂，其表达式为：
```java
OuterClassName.this.propertyName;
```
可以使用外围类的实例去实例化一个内部类：
```java
outerObject.new InnerClass();
```
看起来很奇怪的语法吧。
>内部类是一种编译器现象与虚拟机无关，编译器会将内部类编译成用$符号分隔外部类与内部类的常规类文件。
>甚至可以在一个方法内定义局部内部类。这样它对外部完全隐藏起来了。

局部类可以访问外部类的，还可以访问局部变量，但是那些局部变量必须声明为final的，这样局部与会在局部变量释放之前进行备份。声明为final的是为了保证初始化之后不能再修改其值，

### 匿名内部类 ###
如果只创建类的一个对象，就不需要命名这个类了，这种类称为匿名内部类，其代和实例化一个接口有点相似，直接new一个接口，在后面接一个花括号编写方法的实现代码。

```java
ActionListener listener = new ActionListener() {
	public void actionPerformed(AcionEvent event) {
		do something here
	}
};
```

一种实例化List的“双括号初始化”方法利用内部内的语法：

```java
new ArrayList<String>() {{ add("string1"); add(string2); }}
```
外层括号建立了一个ArrayList的一个匿名子类，内层括号则是一个对象构造块。

静态内部类：
当内部类不需要对外围类的引用是，应该声明为static，以便消除产生引用。一个常用的场景是一个方法要返回两个数值时，可以定义一个包含两个值的类Pair，然后返回这个内部类。
> 只有内部类能声明为static的。静态内部类没有对生成它的外围类对象的引用特权。

## 代理 ##
**使用接口可以在运行时创建一个实现了一组给定接口的新类**
对于应用程序设计人员来说，遇到代理的情况会很少，这是一种高级技术，通常对于系统程序设计人来说，代理非常重要。


